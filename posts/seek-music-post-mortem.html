<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Seek Music Post Mortem — Tai Tran Blog</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="description" content="Seek Music: A Reflective Post-Mortem on Building a Concert Ticketing Platform">
    <meta name="keywords" content="CRUD">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://blog.taitranz.com/posts/seek-music-post-mortem.html">
    <meta property="og:site_name" content="Tai Tran Blog">
    <meta property="og:title" content="Seek Music Post Mortem — Tai Tran Blog">
    <meta property="og:description" content="Seek Music: A Reflective Post-Mortem on Building a Concert Ticketing Platform">

    <link rel="icon" href="../assets/favicon_io/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/favicon_io/favicon-16x16.png">
    <link rel="manifest" href="../assets/favicon_io/site.webmanifest">

    <link rel="canonical" href="https://blog.taitranz.com/posts/seek-music-post-mortem.html">

    <link rel="stylesheet" href="../assets/styles/fonts.css">
    <link rel="stylesheet" href="../assets/styles/variables.css">
    <link rel="stylesheet" href="../assets/styles/media-queries.css">
    <link rel="stylesheet" href="../assets/styles/main.css">
</head>

<body>
    <header class="blog-header">
        <div class="content">
            <h1>
                <a href="../index.html" style="color: inherit; text-decoration: none;">Tai Tran</a>
            </h1>
            <div class="hamburger-menu-centered" aria-label="Toggle navigation menu">
                <span></span>
                <span></span>
            </div>
        </div>
    </header>
    <nav class="blog-nav">
        <div class="item toc-heading">Table of Contents</div>
        <div class="toc-items">
        <div class="item toc-item level-2" data-target="the-feature-landscape-what-was-built">
            <a href="#the-feature-landscape-what-was-built">The Feature Landscape: What Was Built</a>
        </div>
        <div class="item toc-item level-2" data-target="implementation-challenges-the-battles-beneath-the-surface">
            <a href="#implementation-challenges-the-battles-beneath-the-surface">Implementation Challenges: The Battles Beneath the Surface</a>
        </div>
        <div class="item toc-item level-2" data-target="the-bad-technical-debt-and-design-flaws">
            <a href="#the-bad-technical-debt-and-design-flaws">The Bad: Technical Debt and Design Flaws</a>
        </div>
        <div class="item toc-item level-2" data-target="the-path-forward-how-it-could-be-improved">
            <a href="#the-path-forward-how-it-could-be-improved">The Path Forward: How It Could Be Improved</a>
        </div>
        <div class="item toc-item level-2" data-target="reflections-on-the-learning-journey">
            <a href="#reflections-on-the-learning-journey">Reflections on the Learning Journey</a>
        </div>
        </div>
    </nav>
    <div class="overlay"></div>
    <main class="blog-main">
        <section class="section blog">
            <div class="content">
                <div class="blog-container">
                    <div class="title">
                        Seek Music Post Mortem
                    </div>
                    <div class="details">
                        <div class="date">
                            2025-11-09T23:03:17+10:00
                        </div>
                        <div class="tags">
                                                        <div class="tag">
                                CRUD
                            </div>
                        </div>
                    </div>
                    <div class="overview">
                        <p>Before diving into the technical analysis, I want to provide some context that shaped this project&#39;s development. This was built just four months into my degree and four months into learning any form of computer programming, with a six-week deadline from conception to deployment. I understand this might read as an excuse for some of the technical decisions and debt discussed throughout this post-mortem, but I believe it&#39;s important context for understanding the learning trajectory and the challenges encountered along the way. Interestingly, this project scored near-perfect marks at university, which speaks to the relatively low expectations in an academic environment. While the project met and exceeded the assignment criteria, I understand there are substantial issues with the codebase that would be unacceptable in a professional setting. This reflection is as much about acknowledging what could have been done differently as it is about recognising how far the journey has come.</p>
<p>Seek Music emerged as an ambitious full-stack web application designed to bridge the gap between music enthusiasts and live concert experiences. Built using Flask and SQLAlchemy, this platform aimed to provide a comprehensive marketplace where event organisers could list concerts and attendees could discover, browse, and book tickets for their favourite artists. What started as a conceptually straightforward CRUD application evolved into a complex system that taught me invaluable lessons about web development, user experience design, and the hidden challenges that lurk beneath seemingly simple features.</p>
<h2 id="the-feature-landscape-what-was-built">The Feature Landscape: What Was Built</h2>
<p>At its core, Seek Music implements a full-featured event management and ticketing system. The authentication system allows users to register and login with their email or username, with passwords securely hashed using bcrypt. Users can maintain profiles complete with profile pictures, contact information, and editable personal details. The platform supports role-based functionality where users can be both event organisers and ticket purchasers, creating a dynamic two-sided marketplace.</p>
<p>The event creation and management system represents the heart of the application. Organisers can create detailed event listings with multiple form fields capturing everything from artist names and event categories to street addresses, cities, and Australian states. Each event supports file uploads for both a featured image and a carousel of preview images, allowing organisers to showcase their events visually. The system automatically generates event-specific directories in the file structure to organise uploaded media. Events are categorised by music genre including Pop, Rap, Rock, Indie, Alternative, Country, and Other, with filtering capabilities built throughout the interface.</p>
<p>The homepage features an immersive experience with an autoplay video background showcasing concert footage, overlaid with a sophisticated search bar that accepts text queries while also providing dropdown filters for genre and location. Below this, users encounter a carousel showcasing the first ten events in the database, displayed with diagonal tile animations that create visual interest. The category section provides quick navigation tiles for each music genre, routing users to filtered event listings.</p>
<p>Event detail pages represent some of the most feature-rich components of the application. Each event page displays comprehensive information including the featured image banner, artist name, event name, date and time formatted in readable strings, complete address details, and a collapsible ticket purchasing interface. The booking system validates ticket availability in real-time, calculates total costs based on quantity requested, and prevents overselling by tracking available tickets. An image carousel with thumbnail previews allows users to browse through event photos, while a comment section enables community engagement around events.</p>
<p>The booking management system provides users with a dedicated &quot;My Booking&quot; page where they can view all active bookings with details about the organiser, artist, event name, cost, and ticket quantity. Users can cancel bookings, which automatically returns the tickets to the available pool and updates the event status accordingly. Similarly, a &quot;My Listing&quot; page allows organisers to manage their created events, view event statuses, and cancel listings. An administrative panel exists with the capability to delete users, events, and comments, providing moderation capabilities.</p>
<p>The application implements dynamic status management where event statuses automatically transition from &quot;Active&quot; to &quot;Inactive&quot; when the event date passes. When all tickets are sold, events automatically update to &quot;Sold Out&quot; status. The search and filtering system allows users to query events by name, filter by category, city, state, or status, and combines multiple filters for refined searches.</p>
<h2 id="implementation-challenges-the-battles-beneath-the-surface">Implementation Challenges: The Battles Beneath the Surface</h2>
<p>The journey to implement these features was fraught with challenges that tested both technical skills and problem-solving abilities. File upload management emerged as one of the most complex systems to implement correctly. The decision to support multiple image uploads for event carousels introduced significant complexity around file handling, storage organisation, and retrieval. The code had to securely handle filenames using werkzeug&#39;s secure_filename function, create event-specific directories dynamically, and copy the featured image to a separate homepage directory for performance optimisation. The most frustrating aspect was implementing the template logic to dynamically detect image file extensions, resulting in those unwieldy conditional statements that check for .jpg, .jpeg, .png, .gif, and .webp formats in sequence.</p>
<p>Form validation presented another layer of difficulty, particularly with the CreateEventForm that includes a multitude of required fields with different data types. Implementing custom validators for the AnyOf constraints on categories and states required careful coordination between the Python forms and the frontend interface. The date and time validation needed to ensure events couldn&#39;t be created in the past, though this validation appears to be missing from the current implementation (a gap I didn&#39;t notice until thoroughly reviewing the code).</p>
<p>The database relationship management, while utilising SQLAlchemy&#39;s ORM, still required careful planning to avoid cascading delete issues. The relationships between User, Event, Booking, and Comment models needed foreign key constraints while ensuring that deleting an event wouldn&#39;t orphan bookings or leave users without reference to their purchase history. The decision to store carousel image filenames as comma-separated strings in a single database column rather than creating a separate EventImage table represents a pragmatic but non-normalised approach that simplified implementation at the cost of database design purity.</p>
<p>URL routing and parameter handling introduced frustration with space-to-hyphen conversions for SEO-friendly URLs. The view_event route requires four parameters including event_username, event_id, event_artist_name, and event_name, all of which must be converted from spaces to hyphens in URLs and converted back for database queries. This created opportunities for bugs, particularly with JavaScript&#39;s replace functionality that had to be invoked inline in onclick handlers.</p>
<p>The real-time ticket availability system required careful transaction management to prevent race conditions. When a user books tickets, the system must decrement event_available_tickets, add a Booking record, and potentially update the event status to &quot;Sold Out&quot; (all within a single transaction). The current implementation lacks sophisticated locking mechanisms, meaning concurrent bookings could theoretically oversell tickets, though this would only manifest under significant load.</p>
<p>State management across the application, particularly for event statuses, required logic scattered across multiple files. The event_categorise.py file contains a loop that checks every event&#39;s date against the current date and updates statuses to &quot;Inactive&quot; whenever the filter_events function is called. This approach works but creates unnecessary database writes and doesn&#39;t update statuses until someone visits the events page. A more elegant solution would involve database views or scheduled background tasks.</p>
<h2 id="the-bad-technical-debt-and-design-flaws">The Bad: Technical Debt and Design Flaws</h2>
<p>Reflecting honestly on this project reveals several areas where the implementation falls short of production-quality standards. The security posture of the application presents significant concerns. The secret key is hardcoded directly in the source code as &#39;secretkeyofseekmusic&#39;, which should instead be stored in environment variables. While I knew this was poor practice at the time, it was permitted by the tutor for the purposes of the assignment, though it&#39;s certainly not something I&#39;d do in a real-world application. The admin panel at /admin_panel has no authentication or authorisation checks, meaning any user who discovers the URL can delete any user, event, or comment. The remember me functionality creates a cookie with a placeholder token &#39;some_token&#39; that isn&#39;t actually validated on subsequent requests, rendering the feature cosmetic rather than functional.</p>
<p>The code exhibits substantial repetition and violations of the DRY principle. The state abbreviation conversion logic appears identically in both create_event.py and edit_event.py with lengthy if-elif chains that should be extracted into a utility function or dictionary mapping. The template files duplicate the entire navigation bar structure in view-specific-event.html rather than extending it from base.html, creating maintenance headaches. The diagonal button styling in home.html includes ten separately defined CSS classes (.diagonal-btn-1 through .diagonal-btn-10) that differ only minimally and should be parameterised.</p>
<p>Error handling is conspicuously minimal throughout the application. Most routes lack try-except blocks, meaning database errors, file system issues, or unexpected input could crash the application with exposed stack traces. The file upload functionality doesn&#39;t validate file sizes, potentially allowing users to upload gigabyte-sized images that would exhaust server storage. The ticket booking system doesn&#39;t display user-friendly error messages when attempting to purchase more tickets than available; it simply prints to console and silently continues.</p>
<p>The database design includes several normalisation violations beyond the comma-separated carousel images. The Event model duplicates the user&#39;s email and phone number from the User model, storing them as event_email and event_phone_number. If a user updates their contact information, all their existing events retain outdated information. The event_featured_image column stores relative file paths as strings, tightly coupling the database to the filesystem structure.</p>
<p>The frontend implementation suffers from inconsistent user experience patterns. Some forms use Flask-WTF rendering with form.field notation while others manually construct form elements. JavaScript code is embedded directly in template files rather than being extracted into separate .js files, making debugging and maintenance difficult. The responsive design works on desktop but several elements don&#39;t adapt well to mobile viewports, particularly the search bar and diagonal carousel tiles.</p>
<p>Performance optimisation is essentially absent from the application. The home.py route queries individual events with Event.query.filter_by(id=1).first() through Event.query.filter_by(id=10).first(), resulting in ten separate database queries when a single query with a WHERE id IN (1,2,...,10) clause would suffice. The filter_events function loads ALL events into memory before filtering them in Python, rather than constructing SQL WHERE clauses. Images aren&#39;t compressed or resized, and there&#39;s no lazy loading implementation.</p>
<p>The URL structure for events includes redundant information. The route requires both the event_id and the event_username, event_artist_name, and event_name, but the ID alone would be sufficient to uniquely identify an event. This creates longer URLs and multiple valid URLs for the same event, which is problematic for SEO and bookmarking.</p>
<p>Testing is completely absent from the codebase. There are no unit tests for models, no integration tests for routes, and no end-to-end tests for user flows. This makes refactoring dangerous and regressions likely. The debug=True flag in app.py should never be deployed to production, yet there&#39;s no environment-based configuration system to change this behaviour.</p>
<h2 id="the-path-forward-how-it-could-be-improved">The Path Forward: How It Could Be Improved</h2>
<p>Transforming Seek Music from a functional prototype into a production-ready platform would require systematic improvements across multiple dimensions. The security enhancements should be prioritised first. Implementing proper environment variable management using python-dotenv would allow sensitive configuration like secret keys and database URLs to be stored securely. The admin panel needs authentication decorators checking for an admin role stored in the User model. The remember me functionality should generate secure random tokens, store them in a new RememberToken table with user_id and expiration timestamps, and validate them on each request. Implementing rate limiting with Flask-Limiter would prevent brute force attacks on login endpoints.</p>
<p>The codebase structure would benefit from a comprehensive refactoring into a more maintainable architecture. Creating a utils.py module to house the state abbreviation conversion, file extension detection, and other helper functions would eliminate repetition. Extracting the navigation bar into a separate nav.html template that&#39;s included rather than duplicated would ensure consistency. The static JavaScript should be moved into separate files in the static/js/ directory with proper module organisation. Implementing a service layer between routes and database models would separate business logic from HTTP handling, making the code more testable and maintainable.</p>
<p>The database schema deserves a redesign pass. Creating an EventImage table with columns for event_id, image_type (featured vs carousel), image_path, and display_order would properly normalise the image storage. Removing the duplicated email and phone number from the Event model and instead accessing them through the relationship to User would eliminate data inconsistency. Adding database indexes on frequently queried fields like event_category, event_city, event_date, and event_status would dramatically improve query performance.</p>
<p>Error handling and validation should be implemented comprehensively. Each route should be wrapped in try-except blocks catching specific exceptions like SQLAlchemyError, FileNotFoundError, and ValidationError, with user-friendly flash messages and appropriate HTTP status codes. File uploads should validate MIME types, restrict file sizes, and scan for malicious content. The ticket booking process should use database transactions with proper isolation levels and display clear error messages explaining why a booking failed.</p>
<p>The frontend experience needs modernisation to meet contemporary standards. Implementing a proper responsive design system, perhaps using Bootstrap&#39;s grid more consistently or switching to a modern framework like Tailwind CSS, would ensure mobile compatibility. Extracting JavaScript into modules and implementing a build process with tools like Webpack would enable better code organisation. Adding loading states, skeleton screens, and optimistic UI updates would improve perceived performance. Implementing client-side form validation that matches server-side rules would provide immediate feedback.</p>
<p>Performance optimisation should focus on database query efficiency and asset management. Replacing the N+1 query patterns with eager loading using SQLAlchemy&#39;s joinedload or subqueryload would reduce database round trips. Implementing pagination for event listings and bookings would prevent loading entire tables into memory. Adding image resizing with libraries like Pillow to create thumbnail and web-optimised versions would reduce bandwidth. Implementing caching with Flask-Caching for frequently accessed data like the category list and featured events would reduce database load.</p>
<p>The booking system needs additional business logic to handle real-world scenarios. Implementing a temporary reservation system that holds tickets for a user during checkout would prevent them from being sold while someone is completing their purchase. Adding a refund workflow rather than just cancellation would make the booking status more sophisticated. Implementing email notifications for booking confirmations, event reminders, and cancellations would improve communication. Adding a payment gateway integration with Stripe or PayPal would move this from a prototype to a functional marketplace.</p>
<p>Testing infrastructure should be established as a foundation for future development. Creating pytest fixtures for test users, events, and bookings would enable comprehensive unit testing. Implementing factory patterns with Factory Boy would make test data generation simple. Writing integration tests for each route that verify response codes, database changes, and redirects would catch regressions. Implementing end-to-end tests with Selenium or Playwright would verify critical user flows like registration, event creation, and booking.</p>
<p>The deployment architecture needs consideration for production environments. Creating separate configuration objects for development, testing, and production would allow environment-specific settings. Implementing proper logging with Python&#39;s logging module and external services like Sentry would enable debugging production issues. Setting up a production WSGI server like Gunicorn behind Nginx would provide proper request handling. Implementing database migrations with Flask-Migrate would allow schema evolution without data loss.</p>
<h2 id="reflections-on-the-learning-journey">Reflections on the Learning Journey</h2>
<p>Building Seek Music provided invaluable insights into the complexities of full-stack web development. The most significant lesson was understanding that feature implementation is only a fraction of building a real application; the majority of effort should go into error handling, security, testing, and performance optimisation. The tendency to prioritise new features over refactoring existing code created technical debt that compounded over time, making later features more difficult to implement cleanly. This project made me realise that product velocity must be balanced with code quality. While the pressure to deliver features quickly is real, especially under tight deadlines, the shortcuts taken to move faster ultimately slow down development as the codebase becomes harder to understand, modify, and debug.</p>
<p>The importance of planning database schemas thoroughly before implementation became evident when relationship management created complications. Starting with a more normalised design would have prevented data duplication and made the application more maintainable. Similarly, establishing coding patterns and conventions at the project&#39;s outset rather than evolving them organically would have resulted in more consistent code.</p>
<p>The challenge of balancing feature richness with code quality emerged as a constant tension. The desire to implement carousel tiles, comment sections, and sophisticated booking systems was exciting, but each added feature introduced new surface area for bugs and maintenance burden. A more iterative approach (building a minimal viable product first, then adding features incrementally while maintaining high quality) would have resulted in a more robust application.</p>
<p>The frontend development highlighted the importance of design systems and component libraries. Building everything from scratch with custom CSS resulted in inconsistent spacing, colours, and interaction patterns. Adopting a design system early would have accelerated development while ensuring visual consistency. Similarly, the scattered JavaScript demonstrated the value of frontend frameworks like React or Vue that enforce component architecture and state management patterns.</p>
<p>Security considerations were consistently underestimated throughout development. Features like authentication, file uploads, and the admin panel were implemented with a focus on functionality, with security as an afterthought. This pattern is dangerous and demonstrated the necessity of integrating security considerations from the first line of code rather than attempting to bolt them on later.</p>
<p>Perhaps most importantly, this project illuminated the gap between &quot;working code&quot; and &quot;production-ready code.&quot; Seek Music functions; users can register, create events, book tickets, and leave comments. However, the absence of proper error handling, testing, security hardening, and performance optimisation means it falls far short of what would be acceptable in a professional context. Understanding this gap and learning what it takes to bridge it represents the most valuable outcome of this project.</p>
<p>The experience of building Seek Music transformed theoretical knowledge about web development frameworks, database design, and user authentication into practical understanding earned through debugging sessions, refactoring cycles, and discovering edge cases. While the codebase contains numerous flaws and architectural decisions I would change with hindsight, it represents an authentic learning journey (one where mistakes were made, lessons were learned, and the foundation was laid for building better applications in the future). Every hardcoded secret key, every N+1 query, and every duplicated code block serves as a reminder of what not to do next time, making this project an invaluable stepping stone toward mastery of web development.</p>
<p>Throughout this post-mortem, I&#39;ve discussed numerous improvements that could transform this codebase into production-ready software. While I haven&#39;t yet spent time implementing these solutions as I&#39;m currently preoccupied with Valgo (my current project), the lessons learned have fundamentally changed my approach to new projects. Moving forward, I&#39;ve adapted by committing to research heavily before implementing code. Rather than diving straight into development and discovering issues along the way, I now invest time upfront in understanding architectural patterns, security best practices, and potential pitfalls. This shift from &quot;learn by breaking things&quot; to &quot;learn before building things&quot; represents perhaps the most valuable transformation that emerged from this project&#39;s challenges.</p>

                    </div>
                </div>
            </div>
        </section>
    </main>
    <script src="../assets/scripts/blog-post.js"></script>
</body>

</html>
