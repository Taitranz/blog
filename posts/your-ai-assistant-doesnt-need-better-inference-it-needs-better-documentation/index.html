<!DOCTYPE html>
<html lang="en"
    ><head
        ><meta charset="UTF-8" /><title>Your AI Assistant Doesn&#39;t Need Better Inference. It Needs Better Documentation | Brisbane Software Engineering</title
        ><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta
            name="description"
            content="Brisbane software engineering case study on designing a documentation architecture for AI-assisted development, using agent files and structured documentation to improve code quality, consistency and developer productivity."
        /><meta name="keywords" content="Brisbane software engineering, AI Development, Documentation, Code Quality, Developer Productivity" /><meta name="author" content="Tai Tran" /><meta
            property="og:type"
            content="article"
        /><meta property="og:url" content="https://blog.taitranz.com/posts/your-ai-assistant-doesnt-need-better-inference-it-needs-better-documentation" /><meta
            property="og:site_name"
            content="Tai Tran Blog"
        /><meta property="og:title" content="Your AI Assistant Doesn&#39;t Need Better Inference. It Needs Better Documentation | Brisbane Software Engineering" /><meta
            property="og:description"
            content="Brisbane software engineering perspective on documentation architecture for AI-assisted development, improving code quality, consistency and developer productivity."
        /><meta property="og:image" content="https://blog.taitranz.com/assets/images/less-inference-more-documentation.png" /><meta
            property="article:author"
            content="Tai Tran"
        /><meta property="article:published_time" content="2025-11-10T02:00:00.000Z" /><meta
            property="article:modified_time"
            content="2025-11-09T16:22:19.539Z"
        /><link rel="icon" href="../../assets/favicon_io/favicon.ico" type="image/x-icon" /><link
            rel="apple-touch-icon"
            sizes="180x180"
            href="../../assets/favicon_io/apple-touch-icon.png"
        /><link rel="icon" type="image/png" sizes="32x32" href="../../assets/favicon_io/favicon-32x32.png" /><link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="../../assets/favicon_io/favicon-16x16.png"
        /><link rel="manifest" href="../../assets/favicon_io/site.webmanifest" /><link
            rel="canonical"
            href="https://blog.taitranz.com/posts/your-ai-assistant-doesnt-need-better-inference-it-needs-better-documentation"
        /><link rel="stylesheet" href="../../assets/styles/fonts.css" /><link rel="stylesheet" href="../../assets/styles/variables.css" /><link
            rel="stylesheet"
            href="../../assets/styles/main.css"
        /><link rel="stylesheet" href="../../assets/styles/media-queries.css" /><link rel="stylesheet" href="../../assets/styles/highlight.css" />

        <script type="application/ld+json">
            {
                "@context": "https://schema.org",
                "@type": "BlogPosting",
                "headline": "Your AI Assistant Doesn't Need Better Inference. It Needs Better Documentation",
                "description": "Brisbane software engineering case study on designing a documentation architecture for AI-assisted development, using agent files and structured documentation to improve code quality, consistency and developer productivity.",
                "mainEntityOfPage": {
                    "@type": "WebPage",
                    "@id": "https://blog.taitranz.com/posts/your-ai-assistant-doesnt-need-better-inference-it-needs-better-documentation"
                },
                "author": { "@type": "Person", "name": "Tai Tran", "url": "https://taitranz.com/" },
                "publisher": {
                    "@type": "Organization",
                    "name": "Tai Tran Blog",
                    "url": "https://blog.taitranz.com",
                    "logo": { "@type": "ImageObject", "url": "https://blog.taitranz.com/assets/favicon_io/android-chrome-512x512.png" }
                },
                "datePublished": "2025-11-10T02:00:00.000Z",
                "dateModified": "2025-11-09T16:22:19.539Z",
                "image": "https://blog.taitranz.com/assets/images/less-inference-more-documentation.png"
            }
        </script> </head
    ><body
        ><header class="blog-header"
            ><div class="content"
                ><h1><a href="../../" style="color: inherit; text-decoration: none">Tai Tran</a></h1
                ><div class="hamburger-menu-centered" aria-label="Toggle navigation menu"><span></span><span></span></div></div></header
        ><nav class="blog-nav"
            ><div class="item toc-heading">Table of Contents</div
            ><div class="toc-items"
                ><div class="item toc-item level-description" data-target="post-top"
                    ><a href="#post-top">Your AI Assistant Doesn&#39;t Need Better Inference.<br />It Needs Better Documentation</a></div
                ><div class="item toc-item level-2" data-target="introduction"><a href="#introduction">Introduction</a></div
                ><div class="item toc-item level-2" data-target="the-context-problem-in-ai-assisted-development"
                    ><a href="#the-context-problem-in-ai-assisted-development">The Context Problem in AI-Assisted Development</a></div
                ><div class="item toc-item level-2" data-target="the-solution-structured-documentation-architecture"
                    ><a href="#the-solution-structured-documentation-architecture">The Solution: Structured Documentation<br />Architecture</a></div
                ><div class="item toc-item level-2" data-target="layer-1-the-entry-point-files"
                    ><a href="#layer-1-the-entry-point-files">Layer 1: The Entry Point Files</a></div
                ><div class="item toc-item level-2" data-target="layer-2-the-agent-folder"
                    ><a href="#layer-2-the-agent-folder">Layer 2: The .agent Folder</a></div
                ><div class="item toc-item level-2" data-target="decorators"><a href="#decorators">Decorators</a></div
                ><div class="item toc-item level-2" data-target="best-practices"><a href="#best-practices">Best Practices</a></div
                ><div class="item toc-item level-2" data-target="implementation-step-by-step-guide"
                    ><a href="#implementation-step-by-step-guide">Implementation: Step-by-Step Guide</a></div
                ><div class="item toc-item level-2" data-target="benefits-measuring-impact"
                    ><a href="#benefits-measuring-impact">Benefits: Measuring Impact</a></div
                ><div class="item toc-item level-2" data-target="key-principles-and-best-practices"
                    ><a href="#key-principles-and-best-practices">Key Principles and Best Practices</a></div
                ><div class="item toc-item level-2" data-target="common-pitfalls-to-avoid"><a href="#common-pitfalls-to-avoid">Common Pitfalls to Avoid</a></div
                ><div class="item toc-item level-2" data-target="alternatives-and-comparisons"
                    ><a href="#alternatives-and-comparisons">Alternatives and Comparisons</a></div
                ><div class="item toc-item level-2" data-target="advanced-patterns"><a href="#advanced-patterns">Advanced Patterns</a></div
                ><div class="item toc-item level-2" data-target="measuring-roi"><a href="#measuring-roi">Measuring ROI</a></div
                ><div class="item toc-item level-2" data-target="conclusion"><a href="#conclusion">Conclusion</a></div
                ><div class="item toc-item level-2" data-target="resources"><a href="#resources">Resources</a></div></div
            ></nav
        ><div class="overlay"></div
        ><main class="blog-main"
            ><section class="section blog"
                ><div class="content"
                    ><div class="blog-container" id="post-top"
                        ><div class="blog-banner"
                            ><img
                                src="../../assets/images/less-inference-more-documentation.png"
                                alt="Scaling AI-Assisted Development: A Documentation Architecture for Better Code Quality" /></div
                        ><div class="title"> Your AI Assistant Doesn&#39;t Need Better Inference. It Needs Better Documentation </div
                        ><div class="details"
                            ><div class="date"> 10-11-2025 12:00:00 </div
                            ><div class="tags"
                                ><div class="tag"> AI Development </div><div class="tag"> Documentation </div><div class="tag"> Code Quality </div
                                ><div class="tag"> Developer Productivity </div></div
                            ></div
                        ><div class="overview"
                            ><h3 id="scaling-ai-assisted-development-a-documentation-architecture-for-better-code-quality"
                                >Scaling AI-Assisted Development: A Documentation Architecture for Better Code Quality</h3
                            ><h2 id="introduction">Introduction</h2
                            ><p
                                >Over the past year, I've transitioned to writing most of my code with AI assistance. Like many developers exploring AI-powered
                                workflows, I initially treated AI coding assistants as smart autocomplete (helpful for boilerplate, decent at implementing
                                straightforward features, but requiring constant supervision and correction).</p
                            ><p
                                >Most of this has been in Brisbane software engineering contexts: production trading tools, desktop applications, and internal
                                platforms where AI-assisted development must align with strict architecture and quality constraints.</p
                            ><p
                                >The results were mixed. The AI would generate code that worked, but often violated project conventions, ignored architecture
                                patterns, or required extensive refactoring. Each new chat session felt like onboarding a junior developer who had to re-learn
                                the codebase from scratch.</p
                            ><p
                                >I realised the bottleneck wasn't the AI's capabilities. It was how I was providing context. This post details a documentation
                                architecture that solved this problem, dramatically improving the quality and consistency of AI-generated code.</p
                            ><h2 id="the-context-problem-in-ai-assisted-development">The Context Problem in AI-Assisted Development</h2
                            ><h3 id="how-ai-coding-assistants-work">How AI Coding Assistants Work</h3
                            ><p>When you interact with an AI coding assistant, it needs to understand:</p
                            ><ul
                                ><li>Your codebase structure (where files live and how modules interact)</li
                                ><li>Your architecture patterns (<code>Clean Architecture</code>, <code>DDD</code>, <code>MVVM</code>, etc.)</li
                                ><li>Your coding standards (style guides, naming conventions, type safety requirements)</li
                                ><li>Your project constraints (<code>Python</code> version, dependencies, performance requirements)</li
                                ><li>Your domain logic (business rules, data models, API contracts)</li></ul
                            ><p
                                >Without this context, the AI falls back to generic patterns it learned during training. You might ask for a "service class" and
                                get something that looks nothing like your existing service layer.</p
                            ><h3 id="the-traditional-approach-search-and-inference">The Traditional Approach: Search and Inference</h3
                            ><p>Most AI workflows rely on two mechanisms for gathering context:</p
                            ><ol
                                ><li><strong>Semantic Search</strong>: Find relevant code through similarity searches (works for localised changes)</li
                                ><li><strong>Pattern Inference</strong>: Infer conventions from existing code (hit-or-miss approach)</li></ol
                            ><h3 id="why-this-breaks-down">Why This Breaks Down</h3><p>As your project grows, these approaches encounter several problems:</p
                            ><ul
                                ><li
                                    ><strong>Inconsistent sampling</strong>: The AI might examine 3 files that follow one pattern and miss the 10 files that
                                    follow a different (better) pattern</li
                                ><li
                                    ><strong>Missing the "why"</strong>: Code shows what you did, not why you did it. The AI sees you're using mutexes but might
                                    not understand your specific threading constraints</li
                                ><li
                                    ><strong>Context window limitations</strong>: Even with large context windows, the AI can't keep your entire codebase in
                                    memory. It has to choose what to examine, and those choices aren't always optimal</li
                                ><li
                                    ><strong>Implicit knowledge</strong>: Architecture decisions, known issues, and workarounds often live in developers' heads,
                                    not in code</li
                                ><li><strong>Performance cost</strong>: Extensive grepping and searching adds latency to every interaction</li></ul
                            ><h2 id="the-solution-structured-documentation-architecture">The Solution: Structured Documentation Architecture</h2
                            ><p
                                >The approach that worked well inverts the problem: instead of making the AI work harder to infer context, provide explicit,
                                structured documentation that's optimised for AI consumption.</p
                            ><p
                                >This isn't about writing more documentation. It's about organising documentation into layers that match how AI assistants
                                actually work.</p
                            ><h3 id="architecture-overview-two-layer-system">Architecture Overview: Two-Layer System</h3
                            ><p>The system has two distinct layers:</p
                            ><ul
                                ><li><strong>Layer 1: Navigation Files</strong> - Small, always-loaded files that provide high-level rules and pointers</li
                                ><li><strong>Layer 2: Reference Documentation</strong> - Detailed documentation that gets loaded on-demand</li></ul
                            ><p
                                >Think of it like a website: Layer 1 is the homepage and navigation menu, Layer 2 is the individual pages you click through
                                to.</p
                            ><h2 id="layer-1-the-entry-point-files">Layer 1: The Entry Point Files</h2><h3 id="agentsmd-claudemd">AGENTS.md / CLAUDE.md</h3
                            ><p
                                >This file lives in your project root and gets attached to every AI prompt. In <code>Cursor</code> and similar tools, you can
                                configure this as an "always included" file.</p
                            ><h4 id="what-goes-here">What Goes Here:</h4>
                            <pre><code class="hljs language-markdown"><span class="hljs-section"># Project Documentation</span>

<span class="hljs-section">## Start Here</span>

<span class="hljs-bullet">-</span> [<span class="hljs-string">.agent/README.md</span>](<span class="hljs-link">.agent/README.md</span>) - Documentation index
<span class="hljs-bullet">  -</span> Quick system facts and tech stack
<span class="hljs-bullet">  -</span> Recent major features
<span class="hljs-bullet">  -</span> Complete documentation catalogue

<span class="hljs-section">## System Architecture</span>

<span class="hljs-bullet">-</span> [<span class="hljs-string">.agent/System/project_architecture.md</span>](<span class="hljs-link">.agent/System/project_architecture.md</span>)
<span class="hljs-bullet">  -</span> Codebase layout and module organisation
<span class="hljs-bullet">  -</span> Architecture patterns (Clean Architecture, DDD, Event-driven)
<span class="hljs-bullet">  -</span> Data model and database schema

<span class="hljs-section">## Critical Rules</span>

<span class="hljs-section">### Code Quality Rules</span>

<span class="hljs-bullet">1.</span> Never use <span class="hljs-code">`# type: ignore`</span> - fix type issues properly
<span class="hljs-bullet">2.</span> No emojis in code, comments, or log messages
<span class="hljs-bullet">3.</span> Always run linters before completing: <span class="hljs-code">`mypy . ; ruff check`</span>
<span class="hljs-bullet">4.</span> Use LoggingManager, not print statements
<span class="hljs-bullet">5.</span> Use typed domain objects (Value Objects) instead of raw dictionaries

<span class="hljs-section">### AI Code Execution Policy</span>

NEVER run <span class="hljs-code">`python main.py`</span> unless explicitly requested.</code></pre>
                            <h4 id="key-principles">Key Principles</h4
                            ><p
                                >The key to an effective entry point file is keeping it concise and focused. This file should be scannable in seconds. If it
                                grows beyond a few hundred lines, you're doing it wrong. Don't duplicate documentation here; link to it instead. Rules that
                                affect every code change (linting, type safety) go at the top. Update this whenever you add major documentation or change
                                critical rules.</p
                            ><p>Key principles for the entry point file:</p
                            ><ul
                                ><li><strong>Brevity</strong>: Scannable in seconds, under a few hundred lines</li
                                ><li><strong>Pointers over content</strong>: Link to documentation rather than duplicating it</li
                                ><li><strong>Critical rules first</strong>: Linting and type safety rules at the top</li
                                ><li><strong>Living document</strong>: Update when adding major docs or changing critical rules</li></ul
                            ><h3 id="why-this-works">Why This Works</h3
                            ><p>When the AI starts working on a task, it reads this file first. It immediately knows:</p
                            ><ul
                                ><li>What documentation exists and where to find it</li
                                ><li>What rules must never be violated</li
                                ><li>Where to look for specific information</li></ul
                            ><p
                                >This eliminates the "AI doesn't know what it doesn't know" problem. Instead of hoping the AI finds your architecture docs
                                through semantic search, you tell it exactly where they are.</p
                            ><h2 id="layer-2-the-agent-folder">Layer 2: The .agent Folder</h2><h3 id="structure">Structure</h3>
                            <pre><code class="hljs">.agent/
├── README.md                          # Documentation index
├── System/
│   └── project_architecture.md        # Complete system reference (1400+ lines)
├── docs/
│   ├── logging_guide.md               # Feature-specific guides
│   ├── forex_providers/
│   │   ├── README.md
│   │   └── oanda-data-gaps.md
│   └── quirks/                        # Known issues and workarounds
│       ├── vispy-interval-switching-crash.md
│       ├── border-radius-background-issue.md
│       └── stylesheet-vs-palette.md
├── rules/
│   └── coding_preferences.md          # Detailed coding standards
└── technique/
    └── batched-line-segments.md       # Implementation techniques</code></pre>
                            <h3 id="the-documentation-index-agentreadmemd">The Documentation Index (.agent/README.md)</h3
                            ><p
                                >This is the second navigation layer. While <code>AGENTS.md</code> provides high-level pointers, <code>README.md</code> provides
                                a detailed table of contents.</p
                            ><h4 id="example-structure">Example structure:</h4>
                            <pre><code class="hljs language-markdown"><span class="hljs-section"># Project Documentation</span>

<span class="hljs-section">## Start Here</span>

<span class="hljs-bullet">-</span> <span class="hljs-strong">**[README.md]**</span> - This file, documentation index
<span class="hljs-bullet">-</span> <span class="hljs-strong">**[System/project<span class="hljs-emphasis">_architecture.md]** - Complete system reference
  - Section 1: Codebase Layout
  - Section 2: Architecture Patterns
  - Section 3: Performance Optimizations
  - Section 4: Data Model

## Feature Documentation

### Logging System

- [docs/logging_</span>guide.md] - LoggingManager, decorators, correlation tracking

### Implementation Quirks

- [docs/quirks/vispy-interval-switching-crash.md] - Thread safety for VisPy

## Quick Reference

**</span>Python Version:** 3.13.8
<span class="hljs-strong">**Tech Stack:**</span> PySide6 (Qt6), VisPy (OpenGL), SQLite (WAL mode)
<span class="hljs-strong">**Key Patterns:**</span> DI (ServiceContainer), Event Bus, Repository Pattern, Value Objects</code></pre>
                            <h4 id="why-the-index-matters">Why the index matters</h4
                            ><p>When <code>project_architecture.md</code> is 1400 lines long, the AI needs a map. Without it, the AI either:</p
                            ><ul
                                ><li>Reads the entire file (slow, wastes context window)</li
                                ><li>Tries to guess which section is relevant (often wrong)</li
                                ><li>Skips it entirely (loses critical context)</li></ul
                            ><p
                                >With an index that says "Section 3: Performance Optimizations includes event coalescing and mutex patterns," the AI can
                                navigate directly to the relevant section.</p
                            ><h3 id="project-architecture-document">Project Architecture Document</h3
                            ><p>This is your comprehensive system reference. In my case, it's 1400+ lines covering:</p
                            ><h4 id="codebase-layout">Codebase Layout</h4>
                            <pre><code class="hljs">core/
├── domain/           # Business logic, entities, value objects
├── application/      # Use cases, application services
└── infrastructure/   # Database, external APIs

adapters/
├── persistence/      # SQLite repository implementations
└── external/         # Third-party service adapters

gui/
├── viewmodels/       # MVVM view models
├── widgets/          # Qt custom widgets
└── chart/            # VisPy chart components

shared/
├── events/           # Event bus and event definitions
└── logging/          # LoggingManager</code></pre>
                            <h4 id="architecture-patterns">Architecture Patterns</h4><p>The system uses several key architectural approaches:</p
                            ><ul
                                ><li>Clean Architecture with clear layer boundaries</li
                                ><li>Domain-Driven Design with bounded contexts</li
                                ><li>Event-driven communication via <code>EventBus</code></li
                                ><li>CQRS for read/write separation</li
                                ><li>Repository pattern for data access</li></ul
                            ><h4 id="performance-patterns">Performance Patterns</h4><p>To optimise performance, the system employs:</p
                            ><ul
                                ><li>Event coalescing: Batching rapid events (mouse moves, resize events) to reduce processing</li
                                ><li>Mutex protection: <code>QMutex</code> for thread-safe data updates</li
                                ><li>Axis tick throttling: Debouncing expensive label recalculations</li
                                ><li>GPU acceleration: <code>CuPy</code> for RTX GPUs</li></ul
                            ><h4 id="data-model">Data Model</h4>
                            <pre><code class="hljs language-python"><span class="hljs-comment"># Domain Entity Example</span>
<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MarketDataPoint</span>:
    timestamp: datetime
    <span class="hljs-built_in">open</span>: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: <span class="hljs-built_in">int</span>

<span class="hljs-comment"># Value Object Example</span>
<span class="hljs-meta">@dataclass(<span class="hljs-params">frozen=<span class="hljs-literal">True</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeInterval</span>:
    value: <span class="hljs-built_in">str</span>  <span class="hljs-comment"># "M1", "M5", "H1", "D1"</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_seconds</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-comment"># ...</span></code></pre>
                            <p
                                ><strong>Key insight</strong>: This document serves as both AI reference and human onboarding. When a new developer (human or
                                AI) joins, this is their system bible.</p
                            ><h3 id="feature-specific-guides">Feature-Specific Guides</h3
                            ><p>Some features are complex enough to deserve dedicated documentation. In my project:</p
                            ><h4 id="logging-guide-docsloggingguidemd">Logging Guide (docs/logging_guide.md)</h4>
                            <pre><code class="hljs language-markdown"><span class="hljs-section"># Logging System</span>

<span class="hljs-section">## LoggingManager</span>

Central logging with profiles and keyword filtering.

<span class="hljs-section">## Usage</span>

<span class="hljs-code">```python
from shared.logging import get_logger

logger = get_logger(__name__)
logger.info("Processing data", extra={"correlation_id": ctx.correlation_id})</span></code></pre>
                            <h2 id="decorators">Decorators</h2
                            ><ul
                                ><li><code>@debug_trace</code> - Trace function entry/exit</li
                                ><li><code>@timing</code> - Measure execution time</li></ul
                            ><h2 id="best-practices">Best Practices</h2
                            ><ul
                                ><li>Always use <code>logger.info/debug</code>, never <code>print()</code></li
                                ><li>Include <code>correlation_id</code> for request tracing</li
                                ><li>Use structured logging with <code>extra={}</code></li></ul
                            >
                            <pre><code class="hljs">
This level of detail would clutter `project_architecture.md`, but as a separate file, it's available when the AI is working on logging-related features.

### Quirks Documentation

This is documentation gold: known issues and their solutions.

#### Example: VisPy Thread Safety (`docs/quirks/vispy-interval-switching-crash.md`)

```markdown
# VisPy Crash on Rapid Interval Switching

## Problem

Rapidly switching chart intervals crashes the application due to thread safety issues in VisPy updates.

## Root Cause

- Data updates happen on background threads
- VisPy rendering happens on Qt main thread
- No synchronisation leads to race conditions

## Solution

1. Protect chart data with QMutex
2. Update data only when mutex can be acquired
3. Skip updates if chart is mid-render

## Implementation

```python
class ChartCanvas:
    def __init__(self):
        self._data_mutex = QMutex()
    
    def update_data(self, data):
        if self._data_mutex.tryLock(10):  # 10ms timeout
            try:
                self._line.set_data(data)
            finally:
                self._data_mutex.unlock()</code></pre>
                            <p
                                ><strong>Why this matters</strong>: Without this documentation, the AI might suggest data updates without mutex protection,
                                reintroducing the bug. With it, the AI knows to use mutexes whenever touching VisPy data.</p
                            ><h3 id="coding-preferences">Coding Preferences</h3><p>Detailed coding standards that go beyond simple style rules:</p>
                            <pre><code class="hljs language-markdown"><span class="hljs-section"># Coding Preferences</span>

<span class="hljs-section">## Architecture Boundaries</span>

<span class="hljs-bullet">-</span> <span class="hljs-code">`gui/`</span> may import from <span class="hljs-code">`core/`</span> but not vice versa
<span class="hljs-bullet">-</span> <span class="hljs-code">`core/domain/`</span> must not import from <span class="hljs-code">`core/infrastructure/`</span>
<span class="hljs-bullet">-</span> Use dependency injection for cross-layer communication

<span class="hljs-section">## Error Handling</span>

<span class="hljs-bullet">-</span> Use Result types for expected errors
<span class="hljs-bullet">-</span> Raise exceptions for programmer errors
<span class="hljs-bullet">-</span> Log all errors with context

<span class="hljs-section">## Event-Driven Patterns</span>

<span class="hljs-bullet">-</span> Coalesce rapid events (mouse moves, resize events)
<span class="hljs-bullet">-</span> Use QTimer with 250ms debounce for event coalescing
<span class="hljs-bullet">-</span> Always unsubscribe from EventBus in cleanup

<span class="hljs-section">## Thread Safety</span>

<span class="hljs-bullet">-</span> Use QMutex for shared data between threads
<span class="hljs-bullet">-</span> Throttle expensive operations (axis labels, tooltip updates)
<span class="hljs-bullet">-</span> Never update Qt widgets from background threads

<span class="hljs-section">## Value Objects</span>

<span class="hljs-bullet">-</span> Use dataclasses with frozen=True
<span class="hljs-bullet">-</span> Include validation in <span class="hljs-strong">__post<span class="hljs-emphasis">_init_</span>_
- Prefer value objects over primitive types</span></code></pre>
                            <h2 id="implementation-step-by-step-guide">Implementation: Step-by-Step Guide</h2
                            ><h3 id="step-1-create-the-entry-point">Step 1: Create the Entry Point</h3
                            ><p>Create <code>AGENTS.md</code> (or <code>CLAUDE.md</code>, <code>COPILOT.md</code>, etc.) in your project root:</p>
                            <pre><code class="hljs language-bash"><span class="hljs-built_in">touch</span> AGENTS.md</code></pre>
                            <p>Start with the absolute minimum:</p>
                            <pre><code class="hljs language-markdown"><span class="hljs-section"># Project Documentation</span>

<span class="hljs-section">## Key Information</span>

<span class="hljs-strong">**Python Version:**</span> 3.x
<span class="hljs-strong">**Tech Stack:**</span> [Your main frameworks]

<span class="hljs-section">## Critical Rules</span>

<span class="hljs-bullet">1.</span> [Your #1 must-follow rule]
<span class="hljs-bullet">2.</span> [Your #2 must-follow rule]

<span class="hljs-section">## Documentation</span>

See <span class="hljs-code">`.agent/README.md`</span> for complete documentation.</code></pre>
                            <p>Configure your AI tool to always include this file.</p
                            ><h3 id="step-2-create-the-agent-folder">Step 2: Create the .agent Folder</h3>
                            <pre><code class="hljs language-bash"><span class="hljs-built_in">mkdir</span> .agent
<span class="hljs-built_in">touch</span> .agent/README.md</code></pre>
                            <p>In <code>.agent/README.md</code>, create your documentation index. Start simple:</p>
                            <pre><code class="hljs language-markdown"><span class="hljs-section"># Documentation Index</span>

<span class="hljs-section">## Architecture</span>

<span class="hljs-bullet">-</span> system<span class="hljs-emphasis">_architecture.md (to be created)

## Rules

- coding_</span>preferences.md (to be created)</code></pre>
                            <h3 id="step-3-document-your-architecture">Step 3: Document Your Architecture</h3
                            ><p>This is the heavy lifting. Create <code>.agent/System/project_architecture.md</code> and document:</p
                            ><ul
                                ><li>Folder structure (what's where and why)</li
                                ><li>Layer responsibilities (what each layer does)</li
                                ><li>Key patterns (architecture patterns you use consistently)</li
                                ><li>Data models (core entities and value objects)</li
                                ><li>Dependencies (major libraries and why you chose them)</li></ul
                            ><p>Don't try to document everything at once. Start with:</p
                            ><ul
                                ><li>A high-level folder structure (20 lines)</li
                                ><li>3-5 key architecture patterns (50 lines)</li
                                ><li>Your most important domain entities (30 lines)</li></ul
                            ><p>You can expand this incrementally.</p
                            ><p
                                ><strong>Alternative approach</strong>: You can use automated tools to generate an initial architecture document (see Resources
                                section), but this is the lazier path. Automated generation saves time but requires you to thoroughly read and verify the output
                                for correctness, completeness, and accuracy to your actual architecture decisions.</p
                            ><h3 id="step-4-add-feature-documentation">Step 4: Add Feature Documentation</h3
                            ><p>As you build features with the AI, whenever you establish a pattern worth remembering, document it:</p>
                            <pre><code class="hljs language-bash"><span class="hljs-built_in">mkdir</span> .agent/docs
<span class="hljs-built_in">touch</span> .agent/docs/feature_name.md</code></pre>
                            <p>Write just enough that the AI could implement a similar feature without asking questions.</p
                            ><h3 id="step-5-capture-quirks">Step 5: Capture Quirks</h3><p>Every time you hit a weird bug or need a workaround, document it:</p>
                            <pre><code class="hljs language-bash"><span class="hljs-built_in">mkdir</span> .agent/docs/quirks
<span class="hljs-built_in">touch</span> .agent/docs/quirks/issue_description.md</code></pre>
                            <p>Include:</p
                            ><ul
                                ><li>Problem description</li
                                ><li>Root cause</li
                                ><li>Solution/workaround</li
                                ><li>Code example</li></ul
                            ><p
                                ><strong>Critical insight</strong>: Quirks documentation is especially important for issues involving technologies, libraries,
                                or patterns that aren't well-represented in AI training data. When dealing with edge cases, unusual library combinations, or
                                niche frameworks, the AI becomes fragile and falls apart easily without concrete examples. A documented quirk with a working
                                code example prevents the AI from repeatedly suggesting solutions that don't work.</p
                            ><h3 id="step-6-iterate">Step 6: Iterate</h3
                            ><p
                                >As you work with the AI, notice when it gets things wrong and ask yourself: "Could documentation have prevented this?" If yes,
                                add or update documentation. Update <code>AGENTS.md</code> if you add new sections.</p
                            ><h2 id="benefits-measuring-impact">Benefits: Measuring Impact</h2
                            ><p>Since implementing this architecture, I've seen concrete improvements:</p><h3 id="1-consistency">1. Consistency</h3
                            ><p><strong>Before</strong>: AI would generate services with different error handling, logging, and structure from file to file.</p
                            ><p><strong>After</strong>: AI consistently generates services that:</p
                            ><ul
                                ><li>Follow the same structure</li
                                ><li>Use <code>LoggingManager</code> instead of <code>print()</code></li
                                ><li>Include proper error handling</li
                                ><li>Respect architecture boundaries</li></ul
                            ><p><strong>Example</strong>: When I asked for a new data provider, the AI automatically:</p
                            ><ul
                                ><li>Created it in <code>adapters/external/</code></li
                                ><li>Implemented the repository interface from <code>core/domain/</code></li
                                ><li>Used the logging patterns from the logging guide</li
                                ><li>Included error handling that matched existing providers</li></ul
                            ><p>No corrections needed.</p><h3 id="2-reduced-iteration-cycles">2. Reduced Iteration Cycles</h3
                            ><ul
                                ><li><strong>Before</strong>: First AI generation, then 3-5 rounds of corrections, then final code</li
                                ><li><strong>After</strong>: First AI generation, maybe 1 correction, then final code</li></ul
                            ><p><strong>Time saved per feature</strong>: ~30-40%</p><h3 id="3-fewer-linting-errors">3. Fewer Linting Errors</h3
                            ><ul
                                ><li
                                    ><strong>Before</strong>: AI would generate code that failed <code>mypy</code> or <code>ruff</code>, requiring manual
                                    fixes</li
                                ><li
                                    ><strong>After</strong>: Because <code>AGENTS.md</code> says "Always run linters before completing," and the linter commands
                                    are documented, the AI catches issues before I see them.</li
                                ></ul
                            ><p><strong>Linting errors in first-pass code</strong>: Reduced by ~70%</p
                            ><h3 id="4-better-architectural-decisions">4. Better Architectural Decisions</h3
                            ><ul
                                ><li><strong>Before</strong>: AI might suggest putting business logic in GUI layer, or mixing concerns</li
                                ><li><strong>After</strong>: AI suggests solutions that fit the existing architecture, respecting layer boundaries</li></ul
                            ><p><strong>Example</strong>: When I needed chart data caching, the AI suggested:</p
                            ><ul
                                ><li>Repository layer for cache implementation (correct layer)</li
                                ><li>Event bus for cache invalidation (existing pattern)</li
                                ><li>Value objects for cache keys (existing pattern)</li></ul
                            ><p>It didn't suggest bolting a cache onto the GUI layer, which it might have without architecture documentation.</p
                            ><h3 id="5-onboarding-speed">5. Onboarding Speed</h3
                            ><ul
                                ><li><strong>Before</strong>: Each new chat session required re-explaining project structure, patterns, rules</li
                                ><li><strong>After</strong>: The AI references documentation automatically. New sessions are productive immediately.</li></ul
                            ><h3 id="6-human-onboarding-benefit">6. Human Onboarding Benefit</h3
                            ><p
                                >An unexpected benefit: This documentation helps human developers too. When my colleague joined the project, they read the same
                                documentation I wrote for the AI and were productive in hours, not days.</p
                            ><h2 id="key-principles-and-best-practices">Key Principles and Best Practices</h2
                            ><h3 id="1-layered-navigation-is-critical">1. Layered Navigation is Critical</h3
                            ><p
                                >The documentation structure follows a clear path from <code>AGENTS.md</code> to <code>.agent/README.md</code> to specific docs.
                                Each layer serves a purpose:</p
                            ><ul
                                ><li><strong>Layer 1</strong>: What must always be known, pointers to everything else</li
                                ><li><strong>Layer 2</strong>: Detailed index, helps navigate large documents</li
                                ><li><strong>Layer 3</strong>: Detailed reference documentation</li></ul
                            ><p>Don't collapse layers. A 1000-line <code>AGENTS.md</code> defeats the purpose.</p
                            ><h3 id="2-pointers-over-duplication">2. Pointers Over Duplication</h3
                            ><p>When you're tempted to copy content from <code>project_architecture.md</code> into <code>AGENTS.md</code>, resist.</p
                            ><p><strong>Bad</strong>:</p>
                            <pre><code class="hljs language-markdown"><span class="hljs-section"># AGENTS.md</span>

<span class="hljs-section">## Architecture Patterns</span>

We use Clean Architecture with:
<span class="hljs-bullet">-</span> Domain layer for business logic
<span class="hljs-bullet">-</span> Application layer for use cases
...</code></pre>
                            <p><strong>Good</strong>:</p>
                            <pre><code class="hljs language-markdown"><span class="hljs-section"># AGENTS.md</span>

<span class="hljs-section">## Architecture</span>

See <span class="hljs-code">`.agent/System/project_architecture.md`</span> for:
<span class="hljs-bullet">-</span> Codebase layout and module organisation
<span class="hljs-bullet">-</span> Architecture patterns (Clean Architecture, DDD)
<span class="hljs-bullet">-</span> Data model and domain entities</code></pre>
                            <h3 id="3-living-documentation">3. Living Documentation</h3
                            ><p>Documentation that's out of date is worse than no documentation. It actively misleads the AI.</p
                            ><p
                                >Make updating docs part of your workflow. Changed an architecture pattern? Update <code>project_architecture.md</code>. New
                                critical rule? Update <code>AGENTS.md</code>. Fixed a nasty bug? Add a quirks document. I treat documentation updates the same
                                way I treat tests: not optional.</p
                            ><h3 id="4-section-targeting-in-large-files">4. Section Targeting in Large Files</h3
                            ><p>When a file exceeds ~200 lines, add clear section headers:</p>
                            <pre><code class="hljs language-markdown"><span class="hljs-section"># Project Architecture</span>

<span class="hljs-section">## Table of Contents</span>

<span class="hljs-bullet">-</span> [<span class="hljs-string">Section 1: Codebase Layout</span>](<span class="hljs-link">#section-1-codebase-layout</span>)
<span class="hljs-bullet">-</span> [<span class="hljs-string">Section 2: Architecture Patterns</span>](<span class="hljs-link">#section-2-architecture-patterns</span>)
<span class="hljs-bullet">-</span> [<span class="hljs-string">Section 3: Performance Optimisations</span>](<span class="hljs-link">#section-3-performance-optimisations</span>)

<span class="hljs-section">## Section 1: Codebase Layout</span>
...

<span class="hljs-section">## Section 2: Architecture Patterns</span>
...</code></pre>
                            <p>This lets the AI (and humans) jump to relevant sections without reading the entire file.</p
                            ><h3 id="5-examples-are-essential">5. Examples Are Essential</h3><p>Whenever possible, include code examples:</p
                            ><p><strong>Bad</strong>:</p>
                            <pre><code class="hljs language-markdown">Use Value Objects for domain data.</code></pre>
                            <p><strong>Good</strong>:</p>
                            <pre><code class="hljs language-markdown">Use Value Objects for domain data:

<span class="hljs-code">```python
@dataclass(frozen=True)
class TimeInterval:
    value: str  # "M1", "M5", "H1"
    
    def __post_init__(self):
        if self.value not in VALID_INTERVALS:
            raise ValueError(f"Invalid interval: {self.value}")</span></code></pre>
                            <p>The AI learns from examples much more effectively than from descriptions.</p
                            ><h3 id="6-document-the-quotwhyquot">6. Document the "Why"</h3><p>Code shows what you did. Documentation should explain why.</p
                            ><p><strong>Bad</strong>:</p>
                            <pre><code class="hljs language-markdown">Use QMutex when updating chart data.</code></pre>
                            <p><strong>Good</strong>:</p>
                            <pre><code class="hljs language-markdown">Use QMutex when updating chart data because:
<span class="hljs-bullet">-</span> Data updates happen on background threads
<span class="hljs-bullet">-</span> VisPy rendering happens on Qt main thread
<span class="hljs-bullet">-</span> Without synchronisation, race conditions cause crashes

See docs/quirks/vispy-interval-switching-crash.md for details.</code></pre>
                            <h2 id="common-pitfalls-to-avoid">Common Pitfalls to Avoid</h2><h3 id="1-too-much-in-agentsmd">1. Too Much in AGENTS.md</h3
                            ><p>I've seen developers try to cram everything into <code>AGENTS.md</code> because "it's always loaded."</p
                            ><p><strong>Problem</strong>: A 2000-line <code>AGENTS.md</code> takes time to process and clutters every interaction.</p
                            ><p><strong>Solution</strong>: Keep <code>AGENTS.md</code> under 300 lines. Use it as a map, not as the territory.</p
                            ><h3 id="2-documentation-without-structure">2. Documentation Without Structure</h3
                            ><p>Just dumping markdown files in a folder doesn't help. The AI needs a navigation structure.</p
                            ><p><strong>Problem</strong>: 20 markdown files in <code>.agent/docs/</code> with no index.</p
                            ><p><strong>Solution</strong>: Maintain <code>.agent/README.md</code> as a proper table of contents.</p
                            ><h3 id="3-stale-documentation">3. Stale Documentation</h3><p>The worst documentation is documentation that's wrong.</p
                            ><p><strong>Problem</strong>: You changed from logging library X to Y, but the docs still reference X. AI generates code using X.</p
                            ><p><strong>Solution</strong>: Make documentation updates non-negotiable. If the PR changes patterns, it updates docs.</p
                            ><h3 id="4-over-documentation">4. Over-Documentation</h3
                            ><p>Not everything needs documentation. You don't need to document simple functions or straightforward CRUD operations.</p
                            ><p><strong>Document</strong>:</p
                            ><ul
                                ><li>Architecture patterns</li
                                ><li>Non-obvious design decisions</li
                                ><li>Known issues and workarounds</li
                                ><li>Complex features</li></ul
                            ><p><strong>Don't document</strong>:</p
                            ><ul
                                ><li>Standard library usage</li
                                ><li>Simple utility functions</li
                                ><li>Self-explanatory code</li></ul
                            ><h3 id="5-treating-it-as-reference-docs-only">5. Treating It As Reference Docs Only</h3
                            ><p>This isn't API reference documentation. It's contextual documentation designed to help the AI make decisions.</p
                            ><p><strong>Focus on</strong>:</p
                            ><ul
                                ><li>"When to use pattern X vs pattern Y"</li
                                ><li>"Why we chose architecture Z"</li
                                ><li>"How feature A interacts with feature B"</li></ul
                            ><p><strong>Not</strong>:</p
                            ><ul
                                ><li>"Function X takes parameter Y and returns Z" (that's what code comments and docstrings are for)</li></ul
                            ><h2 id="alternatives-and-comparisons">Alternatives and Comparisons</h2><h3 id="vs-well-written-code">vs. Well-Written Code</h3
                            ><p
                                ><strong>Argument</strong>: "Good code should be self-documenting. If the AI reads my code, it should understand the
                                patterns."</p
                            ><p
                                ><strong>Response</strong>: This works for understanding what the code does, not why or when to use patterns. Code shows one
                                solution but documentation can explain trade-offs. Finding the right code to read is the hard part. Code doesn't explain known
                                issues or workarounds. Use both. Write clean code and maintain documentation.</p
                            ><p>Why documentation is still necessary:</p
                            ><ul
                                ><li>Code shows one solution, documentation can explain trade-offs</li
                                ><li>Finding the right code to read is the hard part</li
                                ><li>Code doesn't explain known issues or workarounds</li></ul
                            ><h3 id="vs-ai-tools-with-quotcodebase-understandingquot">vs. AI Tools with "Codebase Understanding"</h3
                            ><p><strong>Argument</strong>: "My AI tool has codebase indexing. It understands my project without extra documentation."</p
                            ><p
                                ><strong>Response</strong>: Indexing helps with "what exists" but not with architecture decisions and rationale,
                                project-specific rules and conventions, known issues and their solutions, or performance optimisation patterns. Indexing and
                                documentation are complementary, not alternatives.</p
                            ><p>What indexing misses:</p
                            ><ul
                                ><li>Architecture decisions and rationale</li
                                ><li>Project-specific rules and conventions</li
                                ><li>Known issues and their solutions</li
                                ><li>Performance optimisation patterns</li></ul
                            ><h3 id="vs-traditional-documentation-systems">vs. Traditional Documentation Systems</h3
                            ><p><strong>Argument</strong>: "We already use Confluence/Notion/Wiki. Why duplicate in <code>.agent/</code>?"</p
                            ><p
                                ><strong>Response</strong>: Traditional docs are optimised for human consumption with marketing language and formatting,
                                scattered across multiple pages, potentially outdated information, and not structured for AI consumption. In contrast,
                                <code>.agent/</code> documentation is concise and factual, co-located with code, version controlled, and structured for AI
                                parsing. If you have traditional docs, great. <code>.agent/</code> is the AI-optimised layer on top.</p
                            ><p><strong>Traditional docs</strong>:</p
                            ><ul
                                ><li>Marketing language and formatting</li
                                ><li>Scattered across multiple pages</li
                                ><li>May include outdated information</li
                                ><li>Not structured for AI consumption</li></ul
                            ><p><strong>.agent/ documentation</strong>:</p
                            ><ul
                                ><li>Concise and factual</li
                                ><li>Co-located with code</li
                                ><li>Version controlled</li
                                ><li>Structured for AI parsing</li></ul
                            ><h2 id="advanced-patterns">Advanced Patterns</h2
                            ><h3 id="version-tracking-in-architecture-docs">Version Tracking in Architecture Docs</h3
                            ><p>Add commit hashes to major documentation sections:</p>
                            <pre><code class="hljs language-markdown"><span class="hljs-section">## Performance Optimizations</span>

<span class="hljs-bullet">-</span> Event coalescing implementation
<span class="hljs-bullet">-</span> Axis tick throttling with QTimer debouncing
<span class="hljs-bullet">-</span> Mutex protection for thread safety
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Last Updated:**</span> Commit f09992e (2025-10-29)</code></pre>
                            <p>This helps you know when documentation was last validated against actual code.</p><h3 id="migration-guides">Migration Guides</h3
                            ><p>When you make breaking architecture changes, document the migration:</p>
                            <pre><code class="hljs language-markdown"><span class="hljs-section">## Migration: Logging System Refactor (2025-10-15)</span>

<span class="hljs-section">### Old Pattern (Deprecated)</span>

<span class="hljs-code">```python
print(f"Processing {item}")</span></code></pre>
                            <h3 id="new-pattern">New Pattern</h3>
                            <pre><code class="hljs language-python"><span class="hljs-keyword">from</span> shared.logging <span class="hljs-keyword">import</span> get_logger

logger = get_logger(__name__)
logger.info(<span class="hljs-string">"Processing item"</span>, extra={<span class="hljs-string">"item_id"</span>: item.<span class="hljs-built_in">id</span>})</code></pre>
                            <h3 id="migration-checklist">Migration Checklist</h3
                            ><ul
                                ><li>Replace all <code>print()</code> calls</li
                                ><li>Add <code>correlation_id</code> to log <code>extra</code></li
                                ><li>Remove any old logging imports</li></ul
                            >
                            <pre><code class="hljs">
This helps the AI avoid using deprecated patterns.

### Context-Specific Rules

Sometimes rules apply only in specific contexts:

```markdown
## Thread Safety Rules

### GUI Layer (gui/*)

- NEVER update Qt widgets from background threads
- Use QMetaObject.invokeMethod for cross-thread updates
- All data updates must go through view models

### Chart Layer (gui/chart/*)

- Use QMutex.tryLock() for all VisPy data updates
- 10ms timeout maximum to avoid blocking rendering
- See docs/quirks/vispy-interval-switching-crash.md</code></pre>
                            <p>The AI can apply different rules depending on what it's working on.</p><h2 id="measuring-roi">Measuring ROI</h2
                            ><p>Documentation takes time. Is it worth it?</p><h3 id="initial-investment">Initial investment</h3
                            ><ul
                                ><li>Entry point file (<code>AGENTS.md</code>): 1-2 hours</li
                                ><li>Documentation index: 30 minutes</li
                                ><li>Initial architecture doc: 4-6 hours</li
                                ><li><strong>Total</strong>: ~8 hours</li></ul
                            ><p
                                ><strong>Time-saving option</strong>: Using automated generation commands (<code>generate_project_architecture.md</code> and
                                <code>update_doc.md</code>) can reduce initial documentation time to 2-3 hours. However, this is the lazier approach and
                                requires thorough review time to verify accuracy, completeness, and architectural correctness. Budget at least 1-2 hours for
                                reviewing and correcting automated output. The quality of your documentation still depends on your review and refinement.</p
                            ><h3 id="ongoing-maintenance">Ongoing maintenance</h3
                            ><ul
                                ><li>Update docs when patterns change: ~15 minutes per change</li
                                ><li>Add quirks documentation: ~30 minutes per issue</li
                                ><li><strong>Estimate</strong>: 1-2 hours per month</li></ul
                            ><h3 id="returns">Returns</h3
                            ><ul
                                ><li>Time saved per feature: ~30-40% (measured in my project)</li
                                ><li>If you build 2-3 features per week, that's 2-4 hours saved weekly</li
                                ><li><strong>Break-even</strong>: ~4 weeks</li></ul
                            ><p>After the first month, it's pure profit. Plus, the documentation helps human developers too.</p
                            ><h2 id="conclusion">Conclusion</h2
                            ><p
                                >AI coding assistants are powerful, but they're only as good as the context you provide. Relying solely on semantic search and
                                pattern inference works for small projects but breaks down as complexity grows.</p
                            ><p>Structured documentation architecture solves this by:</p
                            ><ul
                                ><li>Providing explicit context instead of forcing the AI to infer it</li
                                ><li>Organising documentation in layers that match AI workflow</li
                                ><li>Maintaining a single source of truth for architecture decisions</li
                                ><li>Capturing knowledge that doesn't live in code (the "why" and the quirks)</li></ul
                            ><p>The pattern is simple:</p
                            ><ul
                                ><li>Entry point file with rules and pointers</li
                                ><li>Documentation index for navigation</li
                                ><li>Detailed reference docs for architecture, features, and quirks</li></ul
                            ><p
                                >The investment is modest (a few hours upfront, minimal ongoing maintenance), and the returns are substantial: more consistent
                                code, fewer iterations, faster development, and better architecture adherence.</p
                            ><p
                                >If you're writing significant amounts of code with AI assistance, structured documentation isn't optional. It's how you scale
                                the practice from "helpful autocomplete" to "true pair programming."</p
                            ><p>The AI doesn't need to be perfect at inferring your codebase. It just needs good documentation to reference.</p
                            ><h2 id="resources">Resources</h2><p>Want to implement this in your project?</p
                            ><ol
                                ><li>Create <code>AGENTS.md</code> in your project root with critical rules and pointers</li
                                ><li>Create <code>.agent/README.md</code> as your documentation index</li
                                ><li>Create <code>.agent/System/project_architecture.md</code> for architecture documentation</li
                                ><li>Configure your AI tool to always include <code>AGENTS.md</code></li
                                ><li>Document incrementally as you build</li></ol
                            ><p>Start small. Even a basic structure will improve code quality. You can expand the documentation as your project grows.</p
                            ><h3 id="automated-architecture-generation">Automated Architecture Generation</h3
                            ><p
                                >For those who want to save time on the initial setup, you can use automated codebase analysis tools to generate
                                <code>project_architecture.md</code>. However, this is the lazier approach and comes with important caveats. Automated tools
                                scan your codebase and generate documentation based on static analysis, but they can't understand your architectural intentions,
                                design decisions, or the "why" behind your patterns.</p
                            ><p>If you use automated generation, you must thoroughly review the output for:</p
                            ><ul
                                ><li>Accuracy of detected patterns and structures</li
                                ><li>Completeness of architecture decisions</li
                                ><li>Correctness of dependency relationships</li
                                ><li>Missing context about why certain patterns were chosen</li
                                ><li>Incorrect assumptions about your system design</li></ul
                            ><p
                                ><strong>Important</strong>: Use the best AI model available for documentation generation. High-quality documentation requires
                                strong reasoning and comprehensive codebase analysis. In Cursor, use Claude Sonnet 4.5 or the latest frontier model. The quality
                                of generated documentation directly correlates with the model's capabilities.</p
                            ><h3 id="initial-documentation-generation-command">Initial Documentation Generation Command</h3
                            ><p>Save this as <code>.cursor/commands/generate_project_architecture.md</code> (or adapt for your AI tool):</p>
                            <pre><code class="hljs language-markdown">You are an expert codebase analyst and documentation maintainer.
Goal: produce ONE authoritative architecture doc for new engineers and keep the docs index current.

PRIMARY OUTPUT
<span class="hljs-bullet">-</span> Create or update <span class="hljs-code">`.agent/System/project_architecture.md`</span>.
<span class="hljs-bullet">-</span> Also maintain <span class="hljs-code">`.agent/README.md`</span> as an index.

AGENT DOC STRUCTURE

.agent
<span class="hljs-bullet">-</span> Tasks/ # PRDs &amp; implementation plans (optional)
<span class="hljs-bullet">-</span> System/ # System architecture docs
<span class="hljs-bullet">-</span> SOP/ # Task SOPs (migrations, adding routes, etc.)
<span class="hljs-bullet">-</span> README.md # Index of all docs

OPERATING MODES

1) Initialise documentation
<span class="hljs-bullet">   -</span> Deep scan frontend and backend
<span class="hljs-bullet">   -</span> Generate <span class="hljs-code">`project_architecture.md`</span> covering: project goal, structure, tech stack,
<span class="hljs-code">     integration points, data/storage schema, core flows
   - Update `.agent/README.md` with a clean index
</span>
2) Update documentation
<span class="hljs-bullet">   -</span> Read <span class="hljs-code">`.agent/README.md`</span> to understand existing docs
<span class="hljs-bullet">   -</span> Update only what changed in <span class="hljs-code">`project_architecture.md`</span>
<span class="hljs-bullet">   -</span> Refresh <span class="hljs-code">`.agent/README.md`</span> index

CONTENT REQUIREMENTS FOR <span class="hljs-code">`project_architecture.md`</span>

<span class="hljs-section"># 1. Overview - 3-5 sentence system summary and project goal</span>
<span class="hljs-section"># 2. Codebase Layout - Key directories with roles</span>
<span class="hljs-section"># 3. Services and Modules - Purpose, entrypoints, key deps, interfaces</span>
<span class="hljs-section"># 4. Dependency Graphs - Package summary and internal import graphs</span>
<span class="hljs-section"># 5. Data Model - Stores, core entities, relations, migration strategy</span>
<span class="hljs-section"># 6. API Surface - Public endpoints, auth, external integrations</span>
<span class="hljs-section"># 7. Observability and Ops - Logging, metrics, tracing, health checks</span>
<span class="hljs-section"># 8. Security and Compliance - AuthN/Z model, secrets handling</span>
<span class="hljs-section"># 9. Runtime Topologies - Local, staging, prod environments</span>
<span class="hljs-section"># 10. Known Gaps and Risks - Uncertainties and architectural risks</span>
<span class="hljs-section"># 11. Quickstart for New Agents - Prerequisites, bootstrap steps</span>
<span class="hljs-section"># 12. Glossary - Domain terms and acronyms</span>

DOC QUALITY RULES
<span class="hljs-bullet">-</span> Consolidate. No overlap between files
<span class="hljs-bullet">-</span> Prefer concise bullets over prose. No marketing language
<span class="hljs-bullet">-</span> Include file references with line numbers where possible</code></pre>
                            <h3 id="update-existing-documentation-command">Update Existing Documentation Command</h3
                            ><p>Save this as <code>.cursor/commands/update_doc.md</code>:</p>
                            <pre><code class="hljs language-markdown">You are an expert code documentation expert, your goal is to provide super accurate
&amp; up to date documentation of the codebase.

<span class="hljs-section"># When asked to update documentation</span>

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Check git commits first**</span> to understand what has changed:
<span class="hljs-bullet">  -</span> Run <span class="hljs-code">`git log --oneline -30`</span> to see recent commits
<span class="hljs-bullet">  -</span> Review commit messages and changed files
<span class="hljs-bullet">-</span> Read README.md first to understand what already exists
<span class="hljs-bullet">-</span> Update relevant parts in system &amp; architecture design based on git commit analysis:
<span class="hljs-bullet">  -</span> New features and capabilities
<span class="hljs-bullet">  -</span> Architectural changes and refactorings
<span class="hljs-bullet">  -</span> Performance optimizations
<span class="hljs-bullet">-</span> Update the commit hash and date in documentation headers
<span class="hljs-bullet">-</span> Always update the README.md to include an index of all documentation files

<span class="hljs-section"># Best Practices</span>

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Be thorough**</span>: Check at least 20-30 recent commits
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Cross-reference**</span>: Add file references and line numbers
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Use semantic search**</span>: When unclear about a feature
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Summarize changes**</span>: Create a "Recent Major Features" section
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Verify accuracy**</span>: Ensure file paths are still valid</code></pre>
                            <p
                                ><strong>Note</strong>: Always use the best available AI model when generating or updating documentation. Better models produce
                                more accurate architecture analysis, better identify patterns, and generate more comprehensive documentation. The investment in
                                frontier model usage pays off in documentation quality.</p
                            ><p
                                >These commands work with AI coding assistants like Cursor, but require careful review of the generated output regardless of the
                                model used.</p
                            ><p
                                >This approach has transformed how I work with AI coding assistants. The code quality is higher, the development velocity is
                                faster, and onboarding (both AI and human) is dramatically easier. If you're exploring AI-assisted development at scale,
                                structured documentation architecture is worth trying.</p
                            ></div
                        ></div
                    ></div
                ></section
            ></main
        >
        <script src="../../assets/scripts/blog-post.js"></script> </body
></html>
