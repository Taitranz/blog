<!DOCTYPE html>
<html lang="en"
    ><head
        ><meta charset="UTF-8" /><title>Socslingo: A Duolingo-Inspired Java Clone Post-Mortem | Brisbane Software Engineering</title
        ><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta
            name="description"
            content="Brisbane software engineering post-mortem of Socslingo, a Duolingo-inspired JavaFX desktop app for Japanese learning, covering its feature set, architecture trade-offs, technical debt and key lessons."
        /><meta name="keywords" content="Brisbane software engineering, Java, Post Mortem, Desktop Development, JavaFX" /><meta name="author" content="Tai Tran" /><meta
            property="og:type"
            content="article"
        /><meta property="og:url" content="https://blog.taitranz.com/posts/socslingo-a-duolingo-inspired-java-clone" /><meta
            property="og:site_name"
            content="Tai Tran Blog"
        /><meta property="og:title" content="Socslingo: A Duolingo-Inspired Java Clone Post-Mortem | Brisbane Software Engineering" /><meta
            property="og:description"
            content="Brisbane software engineering post-mortem of Socslingo, a Duolingo-inspired JavaFX desktop app for Japanese learning, covering its feature set, architecture trade-offs, technical debt and key lessons."
        /><meta property="og:image" content="https://blog.taitranz.com/assets/images/socslingo_preview.png" /><meta
            property="article:author"
            content="Tai Tran"
        /><meta property="article:published_time" content="2025-11-09T14:09:39.000Z" /><meta
            property="article:modified_time"
            content="2025-11-09T16:21:38.973Z"
        /><link rel="icon" href="../../assets/favicon_io/favicon.ico" type="image/x-icon" /><link
            rel="apple-touch-icon"
            sizes="180x180"
            href="../../assets/favicon_io/apple-touch-icon.png"
        /><link rel="icon" type="image/png" sizes="32x32" href="../../assets/favicon_io/favicon-32x32.png" /><link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="../../assets/favicon_io/favicon-16x16.png"
        /><link rel="manifest" href="../../assets/favicon_io/site.webmanifest" /><link
            rel="canonical"
            href="https://blog.taitranz.com/posts/socslingo-a-duolingo-inspired-java-clone"
        /><link rel="stylesheet" href="../../assets/styles/fonts.css" /><link rel="stylesheet" href="../../assets/styles/variables.css" /><link
            rel="stylesheet"
            href="../../assets/styles/main.css"
        /><link rel="stylesheet" href="../../assets/styles/media-queries.css" /><link rel="stylesheet" href="../../assets/styles/highlight.css" />

        <script type="application/ld+json">
            {
                "@context": "https://schema.org",
                "@type": "BlogPosting",
                "headline": "Socslingo: A Duolingo-Inspired Java Clone Post-Mortem",
                "description": "Brisbane software engineering post-mortem of Socslingo, a Duolingo-inspired JavaFX desktop app for Japanese learning, covering its feature set, architecture trade-offs, technical debt and key lessons.",
                "mainEntityOfPage": { "@type": "WebPage", "@id": "https://blog.taitranz.com/posts/socslingo-a-duolingo-inspired-java-clone" },
                "author": { "@type": "Person", "name": "Tai Tran", "url": "https://taitranz.com/" },
                "publisher": {
                    "@type": "Organization",
                    "name": "Tai Tran Blog",
                    "url": "https://blog.taitranz.com",
                    "logo": { "@type": "ImageObject", "url": "https://blog.taitranz.com/assets/favicon_io/android-chrome-512x512.png" }
                },
                "datePublished": "2025-11-09T14:09:39.000Z",
                "dateModified": "2025-11-09T16:21:38.973Z",
                "image": "https://blog.taitranz.com/assets/images/socslingo_preview.png"
            }
        </script> </head
    ><body
        ><header class="blog-header"
            ><div class="content"
                ><h1><a href="../../" style="color: inherit; text-decoration: none">Tai Tran</a></h1
                ><div class="hamburger-menu-centered" aria-label="Toggle navigation menu"><span></span><span></span></div></div></header
        ><nav class="blog-nav"
            ><div class="item toc-heading">Table of Contents</div
            ><div class="toc-items"
                ><div class="item toc-item level-description" data-target="post-top"
                    ><a href="#post-top">Socslingo: A Duolingo-Inspired Java Clone<br />Post-Mortem</a></div
                ><div class="item toc-item level-2" data-target="what-we-built-feature-overview"
                    ><a href="#what-we-built-feature-overview">What We Built: Feature Overview</a></div
                ><div class="item toc-item level-2" data-target="the-good-what-actually-worked"
                    ><a href="#the-good-what-actually-worked">The Good: What Actually Worked</a></div
                ><div class="item toc-item level-2" data-target="the-okay-functional-but-not-optimal"
                    ><a href="#the-okay-functional-but-not-optimal">The Okay: Functional But Not Optimal</a></div
                ><div class="item toc-item level-2" data-target="the-bad-compromises-and-shortcuts"
                    ><a href="#the-bad-compromises-and-shortcuts">The Bad: Compromises and Shortcuts</a></div
                ><div class="item toc-item level-2" data-target="the-worst-design-flaws-and-technical-debt"
                    ><a href="#the-worst-design-flaws-and-technical-debt">The Worst: Design Flaws and Technical Debt</a></div
                ><div class="item toc-item level-2" data-target="performance-and-scalability-issues"
                    ><a href="#performance-and-scalability-issues">Performance and Scalability Issues</a></div
                ><div class="item toc-item level-2" data-target="what-i-learned-and-would-do-differently"
                    ><a href="#what-i-learned-and-would-do-differently">What I Learned and Would Do Differently</a></div
                ><div class="item toc-item level-2" data-target="how-it-can-be-improved"><a href="#how-it-can-be-improved">How It Can Be Improved</a></div
                ><div class="item toc-item level-2" data-target="conclusion"><a href="#conclusion">Conclusion</a></div></div
            ></nav
        ><div class="overlay"></div
        ><main class="blog-main"
            ><section class="section blog"
                ><div class="content"
                    ><div class="blog-container" id="post-top"
                        ><div class="blog-banner"><img src="../../assets/images/socslingo_preview.png" alt="Socslingo Preview" /></div
                        ><div class="title"> Socslingo: A Duolingo-Inspired Java Clone Post-Mortem </div
                        ><div class="details"
                            ><div class="date"> 10-11-2025 00:09:39 </div
                            ><div class="tags"
                                ><div class="tag"> Java </div><div class="tag"> Post Mortem </div><div class="tag"> Desktop Development </div
                                ><div class="tag"> JavaFX </div></div
                            ></div
                        ><div class="overview"
                            ><p
                                >This was my first real exposure to <code>Java</code>. Coming from other languages, I had six weeks to deliver a functional
                                language learning application as a university project, juggling this alongside other coursework and commitments. The brief was
                                straightforward: build something that demonstrates understanding of object-oriented programming, database integration, and GUI
                                development. What emerged was far more ambitious than the requirements demanded.</p
                            ><p
                                >It also ended up being an early Brisbane software engineering project: a desktop application built under tight constraints that
                                surfaced many of the architectural and delivery trade-offs I now approach more deliberately.</p
                            ><p
                                >The compressed timeline and parallel demands meant that every technical decision became a calculated trade-off between ideal
                                architecture and shipping features, where pragmatism consistently won out over perfectionism. There were moments where I knew
                                the "right" way to solve a problem but opted for the "fast" way instead. Sometimes this was copy-pasting an entire controller
                                and modifying it rather than extracting shared logic. Other times it was hardcoding a path because externalising it to a config
                                file would take an extra hour.</p
                            ><p>Looking back at the final codebase, the scale is somewhat absurd for a six-week solo project:</p
                            ><ul
                                ><li>26 controllers managing different aspects of the UI</li
                                ><li>37 <code>FXML</code> view files defining layouts</li
                                ><li>21 <code>CSS</code> stylesheets for styling (with significant duplication)</li
                                ><li>An intricate web of managers, services, and data access objects that make up the application's architecture</li></ul
                            ><p
                                >The project contains roughly 8,000 lines of <code>Java</code> code across models, services, controllers, and data access
                                layers, plus another few thousand lines of <code>FXML</code> and <code>CSS</code>. For someone learning <code>Java</code> for
                                the first time, this represented both an ambitious vision and the necessary compromises that emerged from working at such
                                intensity.</p
                            ><h2 id="what-we-built-feature-overview">What We Built: Feature Overview</h2
                            ><p
                                >Socslingo emerged as a feature-rich language learning platform, particularly focused on Japanese language study. The
                                application attempts to recreate several core Duolingo mechanics while adding some unique twists.</p
                            ><p
                                >The authentication system supports full user registration and login with <code>SHA-256</code> password hashing (more on the
                                security implications later). Once logged in, users land on a home dashboard that shows their learning statistics and provides
                                access to different study modes. The profile system allows users to upload custom banner images, which get automatically resized
                                to 720x405 pixels and cached for performance. The profile also displays character recognition statistics, tracking how many
                                Hiragana, Katakana, and Kanji characters the user has correctly identified.</p
                            ><p>At the heart of the application is a flashcard system that's more sophisticated than initially planned:</p
                            ><ul
                                ><li>Users can create individual flashcards with front and back text (typically Japanese on one side, English on the other)</li
                                ><li
                                    >Flashcards can be organised into custom decks, with a many-to-many relationship allowing a single flashcard to exist in
                                    multiple decks</li
                                ><li
                                    >The deck management interface includes a right sidebar showing all available flashcards, drag-and-drop style
                                    addition/removal of cards from decks, and real-time previews</li
                                ><li
                                    >When studying, flashcards appear with 3D flip animations, randomised order to prevent memorisation of sequence rather than
                                    content, and progress tracking showing how many cards remain in the session</li
                                ></ul
                            ><p
                                >The character recognition activities are where the Duolingo inspiration is most apparent. Users can practice Hiragana,
                                Katakana, or Kanji through multiple-choice quizzes that present a character and ask them to select the correct reading. The
                                activity screen includes:</p
                            ><ul
                                ><li>A progress bar showing advancement through the lesson</li
                                ><li>A heart-based lives system (starting with 5 hearts, losing one for each incorrect answer or skipped question)</li
                                ><li
                                    >Dynamic UI feedback where the bottom section transitions colour (green for correct, red for incorrect) with smooth
                                    animations</li
                                ><li
                                    >Background preloading of the next question while the user is answering the current one, creating a seamless experience with
                                    no loading delays between questions</li
                                ></ul
                            ><p>The UI throughout features extensive animations:</p
                            ><ul
                                ><li>Fade transitions when switching between major screens</li
                                ><li>Card flip rotations using 3D transforms</li
                                ><li>Progress bar animations that smoothly fill rather than jump to values</li
                                ><li>Colour transitions on UI elements responding to user actions</li
                                ><li>An animated gradient that bounces across a status bar when navigation buttons are clicked</li></ul
                            ><p
                                >An intermission screen featuring the application mascot (a small character graphic) appears with fade effects when
                                transitioning into major activities, providing visual breathing room and hiding any background loading.</p
                            ><p>Scene management handles the complexity of multiple views with different layout requirements:</p
                            ><ul
                                ><li
                                    >Some views (like the home page and deck management) show both left and right sidebars for navigation and context-sensitive
                                    tools</li
                                ><li>Others (like the activity screens) hide both sidebars entirely to maximise focus on the learning content</li
                                ><li>The <code>SceneManager</code> preloads frequently-used scenes like login and registration to eliminate loading delays</li
                                ><li>It manages sophisticated fade in/out transitions with proper timing coordination</li></ul
                            ><h2 id="the-good-what-actually-worked">The Good: What Actually Worked</h2
                            ><h3 id="architecture-that-scaled">Architecture That Scaled</h3
                            ><p
                                >The layered architecture followed a fairly standard <code>MVC</code> pattern, though implemented without any framework beyond
                                <code>JavaFX</code> itself. The separation between controllers (UI logic), services (business logic), data access objects
                                (database operations), and managers (cross-cutting concerns like sessions and scenes) created clear boundaries that actually
                                held up as the codebase grew.</p
                            ><p>The data flow follows a consistent pattern:</p
                            ><ul
                                ><li>Controllers handle <code>FXML</code>-bound UI events and call Services</li
                                ><li>Services contain business logic and call <code>DAOs</code></li
                                ><li><code>DAOs</code> handle all <code>SQL</code> operations and return Model objects</li></ul
                            ><p
                                >When I needed to add character recognition statistics tracking late in development, I could create
                                <code>CharacterRecognitionStatisticsDAO</code> with methods like <code>updateStatistics(userId, correct, incorrect)</code>, wrap
                                it in a <code>CharacterService</code> with business logic for determining when to update stats, and integrate it into the
                                <code>ProfileController</code> to display the data, all without touching the existing flashcard or deck systems.</p
                            ><p
                                >The <code>ControllerManager</code> acts as a primitive dependency injection container. While it's basically a giant switch
                                statement mapping controller classes to their instantiated versions with injected dependencies, it at least keeps all that
                                wiring in one place. Every controller gets its dependencies through constructor injection, which made it reasonably clear what
                                each controller needed. The downside is that adding a new controller means updating the <code>ControllerManager</code>'s call
                                method, adding the service/<code>DAO</code> dependencies if they're new, and making sure the instantiation order doesn't cause
                                any issues.</p
                            ><h3 id="scene-management">Scene Management</h3
                            ><p
                                >The <code>SceneManager</code> centralised navigation logic in a way that actually paid off as the application grew. It manages
                                a single <code>Stage</code> (<code>JavaFX</code>'s top-level window container) and swaps out the <code>Scene</code>'s root
                                <code>Node</code> when switching views, rather than creating multiple stages or windows. This keeps memory usage lower and
                                provides a consistent window size and position.</p
                            ><p
                                >The preloading strategy loads the login and registration <code>FXML</code> files once during initialisation, parses them into
                                the scene graph, applies <code>CSS</code>, and caches the resulting <code>Parent</code> nodes in a <code>HashMap</code> keyed by
                                <code>FXML</code> path. When the user switches between login and registration (which happens frequently during testing and
                                development), the app just swaps in the cached <code>Node</code> with no file I/O or parsing overhead. Non-preloaded scenes get
                                loaded on-demand but still go through the same centralised loading process, applying <code>CSS</code> and setting up fade
                                transitions consistently.</p
                            ><p
                                >The intermission screen deserves its own mention because it demonstrates thinking about user experience beyond pure
                                functionality. When entering character recognition activities, there's a brief pause where the <code>SceneManager</code> shows a
                                cute mascot graphic with fade-in and fade-out animations. This serves multiple purposes:</p
                            ><ul
                                ><li>It provides visual feedback that something is happening</li
                                ><li>It gives the preloading system time to prepare the next activity in the background without the user seeing a frozen UI</li
                                ><li>It creates a psychological "moment" before entering a focused learning session</li></ul
                            ><p
                                >The screen gets preloaded once and reused across all activity transitions, with <code>ImageView</code> sizing bound to the
                                container dimensions so it scales appropriately.</p
                            ><h3 id="image-caching-system">Image Caching System</h3
                            ><p
                                >The <code>ImageCache</code> implementation uses <code>JavaFX</code>'s <code>Service</code> and <code>Task</code> classes for
                                asynchronous loading, which was surprisingly tricky to get right for a first <code>Java</code> project. The cache follows the
                                singleton pattern (for better or worse) and maintains a <code>ConcurrentHashMap&lt;Integer, Image&gt;</code> mapping user IDs to
                                their banner images.</p
                            ><p
                                >On application startup, before showing any UI, the cache scans the <code>profile_banners</code> directory, identifies all image
                                files, extracts user IDs from filenames (which follow the pattern <code>banner_user_{id}_{timestamp}.{ext}</code>), and spawns
                                background threads using <code>JavaFX</code>'s <code>Service</code> to load each image. The <code>Service</code> pattern
                                provides proper lifecycle management, error handling, and the ability to update UI (via <code>Platform.runLater</code>) when
                                loading completes. Each image gets loaded with quality settings maximised (<code>new Image(uri, 0, 0, true, true, true)</code>)
                                to preserve the resizing work done during upload.</p
                            ><p
                                >The <code>ProfileController</code> can then immediately request cached images without any I/O delay. When a user uploads a new
                                banner, the process:</p
                            ><ul
                                ><li>Deletes the old image file</li
                                ><li
                                    >Saves the new one (resizing it to exactly 720x405 pixels using <code>Java AWT</code>'s <code>BufferedImage</code> with
                                    bicubic interpolation for quality)</li
                                ><li>Updates the database path</li
                                ><li>Removes the old image from the cache</li
                                ><li>Preloads the new one in the background</li></ul
                            ><p>This means subsequent profile views show the new image instantly.</p
                            ><p
                                >The major flaw is that nothing ever gets evicted from the cache. Every banner image loaded stays in memory until the
                                application closes. For the expected use case (single user on a desktop machine), this is fine. For a multi-user deployment or
                                long-running instance, this would be a memory leak. An <code>LRU</code> cache with size limits would have been the proper
                                solution, but that would have required implementing or integrating a caching library, and honestly, premature optimisation
                                wasn't the goal.</p
                            ><h3 id="comprehensive-logging">Comprehensive Logging</h3
                            ><p
                                >Using <code>SLF4J</code> with <code>Logback</code> throughout the codebase created an audit trail that helped during
                                development. Every controller, service, and <code>DAO</code> logs its operations. When character recognition activities failed
                                to load, the logs showed which <code>FXML</code> file couldn't be found. When database operations failed, the logs indicated
                                which <code>SQL</code> statement and parameters were involved. This made debugging more straightforward than hunting through
                                stack traces alone.</p
                            ><h3 id="ui-animations">UI Animations</h3><p>The application uses <code>JavaFX</code>'s timeline and transition APIs throughout:</p
                            ><ul
                                ><li>Flashcard flips use <code>RotateTransition</code> with 3D axis rotation</li
                                ><li>The continue/check button morphs between states with style class manipulation and colour transitions</li
                                ><li>The progress bar animates using <code>KeyFrame</code> timelines</li
                                ><li>The bottom section of activity screens changes colour based on answer correctness</li></ul
                            ><p>These animations add polish, though they do add complexity to controllers that are already doing too much.</p
                            ><h2 id="the-okay-functional-but-not-optimal">The Okay: Functional But Not Optimal</h2
                            ><h3 id="state-management">State Management</h3
                            ><p
                                >The application relies heavily on <code>SessionManager</code> for user state and <code>SelectedCategory</code> for activity
                                configuration. While functional, these global singletons create hidden dependencies that make testing difficult and can lead to
                                stale state bugs. For example, the character practice activities read from <code>SelectedCategory.getSelectedCategory()</code>,
                                which means the category selection logic is scattered rather than explicitly passed through the call chain. Similarly, almost
                                every controller accesses <code>SessionManager.getInstance().getCurrentUser()</code> directly. A more robust approach would have
                                been to inject these dependencies or use a proper state management pattern, but for a six-week timeline, these singletons kept
                                things moving.</p
                            ><h3 id="database-connection-management">Database Connection Management</h3
                            ><p
                                >The <code>DatabaseManager</code> follows the singleton pattern and creates new connections on demand with
                                <code>getConnection()</code>. Each data access method opens a connection, executes <code>SQL</code>, and closes it in
                                <code>try-with-resources</code> blocks. This works and prevents connection leaks, but it means we're opening and closing
                                database connections constantly rather than using connection pooling. For a desktop <code>SQLite</code> application with
                                single-user access, the performance impact is negligible, but it represents a scalability limitation. The code also hardcodes
                                the database path (<code>"src/main/database/socslingo_database.db"</code>) rather than making it configurable, which complicated
                                testing and deployment.</p
                            ><h3 id="manual-dependency-wiring">Manual Dependency Wiring</h3
                            ><p
                                >The <code>ControllerManager</code> creates services and data access objects manually, instantiating dependencies at
                                construction time. This pattern appears throughout:</p
                            >
                            <pre><code class="hljs language-java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">(Class&lt;?&gt; controllerClass)</span> {
    <span class="hljs-keyword">if</span> (controllerClass == LoginController.class) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginController</span>(userService);
    }
    <span class="hljs-keyword">if</span> (controllerClass == FlashcardController.class) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlashcardController</span>(flashcardService);
    }
    <span class="hljs-comment">// ... 26 more controllers</span>
}</code></pre>
                            <p
                                >It works, but adding a new controller requires updating this method. A dependency injection framework like
                                <code>Spring</code> or even a simpler solution with reflection would have reduced boilerplate and made the system more
                                maintainable. However, for someone learning <code>Java</code> for the first time, manually wiring dependencies probably provided
                                better understanding of how objects relate to each other.</p
                            ><h3 id="fxml-and-css-proliferation">FXML and CSS Proliferation</h3
                            ><p
                                >With 37 <code>FXML</code> files and 21 <code>CSS</code> files, there's significant duplication in styling and layout. Many
                                views share similar structures (a main content area, buttons with similar styling, headers with similar layouts) yet each is
                                defined separately. <code>JavaFX</code> doesn't have component composition patterns like modern web frameworks, so we ended up
                                with repeated <code>FXML</code> structures. The <code>CSS</code> files show similar patterns; multiple files define variations
                                on button styles that could have been consolidated using better class naming strategies. This made consistent styling changes
                                painful.</p
                            ><h3 id="test-coverage">Test Coverage</h3
                            ><p
                                >The test suite consists entirely of basic model unit tests: verifying getters, setters, constructors, and
                                <code>toString</code> methods. While these tests are well-written and provide value, they're essentially testing
                                <code>Java</code>'s built-in functionality rather than application logic. There are no tests for services, data access objects,
                                or controllers. The business logic that determines whether a flashcard answer is correct, how decks are managed, or how
                                character recognition activities are scored goes untested. For a university project under time pressure, this is understandable
                                (the application works as demonstrated) but it represents technical debt that would need addressing before any production
                                use.</p
                            ><h2 id="the-bad-compromises-and-shortcuts">The Bad: Compromises and Shortcuts</h2
                            ><h3 id="hardcoded-constants-and-magic-strings">Hardcoded Constants and Magic Strings</h3
                            ><p
                                >Throughout the codebase, <code>FXML</code> paths, <code>CSS</code> paths, and resource paths are repeated as string literals.
                                <code>PrimaryController</code> contains a button-to-<code>FXML</code> mapping with strings like
                                <code>"/com/socslingo/views/home.fxml"</code> scattered across multiple methods. If we renamed a view file, we'd need to find
                                and replace it in multiple locations. <code>CSS</code> class names are similarly hardcoded;
                                <code>ActivityMainController</code> manipulates classes like
                                <code>"activity-continue-button__label--medium-type-incorrect-hover"</code> directly in code. These long, hyphenated names are
                                fragile. A typo means a silently failing style change that's hard to debug.</p
                            ><h3 id="inconsistent-error-handling">Inconsistent Error Handling</h3><p>Error handling varies wildly across the codebase:</p
                            ><ul
                                ><li>Some methods show <code>Alert</code> dialogues to users</li
                                ><li>Some log errors and return <code>null</code> or <code>false</code></li
                                ><li>Some throw <code>RuntimeExceptions</code> wrapped around caught exceptions</li
                                ><li>Some silently fail</li></ul
                            ><p
                                ><code>LoginController</code> shows an error label when authentication fails. <code>DeckController</code> shows
                                <code>Alert</code> popups. <code>CharacterRecognitionDataAccess</code> logs errors and returns empty lists. This inconsistency
                                means users get unpredictable feedback, and developers can't trust return values. A unified error handling strategy with proper
                                exception hierarchies would have been much cleaner.</p
                            ><h3 id="password-hashing">Password Hashing</h3><p>While we hash passwords, we use plain <code>SHA-256</code> without salting:</p>
                            <pre><code class="hljs language-java"><span class="hljs-type">MessageDigest</span> <span class="hljs-variable">message_digest</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">"SHA-256"</span>);
<span class="hljs-type">byte</span>[] hashed_bytes = message_digest.digest(password.getBytes(<span class="hljs-string">"UTF-8"</span>));</code></pre>
                            <p
                                >This is better than plaintext, but <code>SHA-256</code> is designed to be fast, which makes it vulnerable to rainbow table and
                                brute force attacks. Modern password hashing should use slow algorithms like <code>bcrypt</code>, <code>scrypt</code>, or
                                <code>Argon2</code> with per-user salts. The codebase actually includes <code>jbcrypt</code> as a dependency in the
                                <code>pom.xml</code>, but we never used it. This represents a security vulnerability that stems from not understanding security
                                best practices (understandable for a first project, but concerning for any real-world use).</p
                            ><h3 id="duplicated-code">Duplicated Code</h3
                            ><p
                                >The <code>ActivityMainController</code> and <code>CharacterPracticeActivityMainController</code> share enormous amounts of
                                duplicate code, representing probably the single worst architectural decision in the entire project. Both files are over 500
                                lines, and at least 70% of that code is nearly identical between them.</p
                            ><p>Both controllers manage:</p
                            ><ul
                                ><li
                                    >A hearts system with the exact same logic: integer counter starting at 5, decrements on wrong answers or skips, check for
                                    zero and exit the activity</li
                                ><li>Progress bars with identical animation code using <code>Timeline</code> and <code>KeyFrame</code></li
                                ><li
                                    >Check/continue button logic that morphs the button between states, applying and removing the same <code>CSS</code> classes
                                    (<code>activity-continue-button__label--medium-type-correct-hover</code>,
                                    <code>activity-button--medium-type-check-answer-unclickable</code>, etc.)</li
                                ><li>Skip functionality that changes the bottom section colour, shows replacement UI, and decreases hearts</li
                                ><li>Background preloading of the next activity using the same <code>Service</code> pattern</li
                                ><li>Fade transitions with identical <code>FadeTransition</code> configurations</li></ul
                            ><p>The only differences are minor:</p
                            ><ul
                                ><li>One activity type uses a three-option multiple choice layout, the other uses character matching pairs</li
                                ><li>The button styling class names vary slightly</li
                                ><li>The <code>FXML</code> paths being loaded are different</li></ul
                            ><p>That's it. Everything else is copy-pasted.</p
                            ><p
                                >This violates <code>DRY</code> principles so badly that when I found a bug in the heart system in one controller, I had to
                                remember to fix it in the other. When I wanted to change the animation duration, I updated it in one place, tested it, liked it,
                                then forgot to update the other until noticing the inconsistency later. An abstract <code>BaseActivityController</code> with
                                template methods for the activity-specific behaviour would have eliminated all this duplication. Or even just extracting the
                                common methods into an <code>ActivityHelper</code> utility class. But under time pressure, copying
                                <code>ActivityMainController.java</code>, renaming it to <code>CharacterPracticeActivityMainController.java</code>, and
                                modifying the 30% that was different was faster than properly refactoring. That's the kind of technical debt that compounds
                                quickly.</p
                            ><h3 id="image-processing-without-error-boundaries">Image Processing Without Error Boundaries</h3
                            ><p
                                >The <code>ProfileController</code> includes sophisticated image resizing code using <code>Java AWT</code>'s
                                <code>BufferedImage</code>:</p
                            >
                            <pre><code class="hljs language-java"><span class="hljs-type">BufferedImage</span> <span class="hljs-variable">finalImage</span> <span class="hljs-operator">=</span> resizeAndCropImage(originalImage, <span class="hljs-number">720</span>, <span class="hljs-number">405</span>, hasAlpha);</code></pre>
                            <p
                                >However, if the user selects a corrupt image, an unsupported format, or an extremely large image that causes memory issues, the
                                error handling is minimal. The method logs exceptions but doesn't provide clear user feedback about what went wrong or how to
                                fix it. The image processing happens synchronously on the UI thread, which could freeze the application with large images. For a
                                profile banner feature, this is acceptable, but it shows a gap in robust file handling.</p
                            ><h2 id="the-worst-design-flaws-and-technical-debt">The Worst: Design Flaws and Technical Debt</h2
                            ><h3 id="the-god-controller-problem">The God Controller Problem</h3
                            ><p
                                ><code>PrimaryController</code> has grown to 829 lines and manages far too many responsibilities. It's become the de facto "main
                                application controller" that everything else depends on, and that's a problem. The class handles:</p
                            ><ul
                                ><li>Scene switching (maintaining the primary <code>Stage</code>, loading <code>FXML</code>, applying <code>CSS</code>)</li
                                ><li>Sidebar visibility (both left nav sidebar and right context sidebar, with animated transitions)</li
                                ><li>Context menu management (including mouse enter/exit timing logic)</li
                                ><li>Button action routing (a giant switch statement mapping button IDs to <code>FXML</code> paths)</li
                                ><li>Animations (gradient wave effects on the status bar)</li
                                ><li>Intermission screen preloading</li
                                ><li>Serves as a singleton accessed throughout the application via <code>getInstance()</code></li></ul
                            ><p>Let's look at what's actually in this file:</p
                            ><ul
                                ><li><code>switchContent(String fxml_path)</code> and its overload with fade durations handle loading new views</li
                                ><li
                                    ><code>showSidebar()</code> and <code>hideSidebar()</code> manage left sidebar animations with
                                    <code>TranslateTransition</code></li
                                ><li><code>showRightSidebar()</code> and <code>hideRightSidebar()</code> do the same for the right sidebar</li
                                ><li><code>preloadIntermissionScreen()</code> loads and caches the mascot animation screen</li
                                ><li
                                    ><code>loadStartupScreen(Node nextContent)</code> orchestrates a complex sequence of fade-to-white, hide-sidebar,
                                    show-intermission, fade-in-content transitions</li
                                ><li><code>setupContextMenu()</code> configures the "More" button's context menu with 3-second auto-hide delay</li
                                ><li><code>applyAnimatedGlowEffect()</code> adds a pulsing drop shadow to the status bar</li
                                ><li><code>applyWaveAnimation()</code> creates an animated gradient that bounces across the status bar</li
                                ><li
                                    ><code>handleButtonAction(ActionEvent event)</code> maps button IDs to <code>FXML</code> paths using a
                                    <code>HashMap</code> lookup</li
                                ><li><code>setActiveButton(Button active_button)</code> manages button styling to show which navigation item is selected</li
                                ><li
                                    ><code>setSidebarVisibility(boolean visible)</code> determines whether sidebars should show based on the current view</li
                                ></ul
                            ><p
                                >All of this in one class. The singleton pattern (accessible via <code>PrimaryController.getInstance()</code>) means virtually
                                every other controller in the system has access to this, and many of them call it directly.
                                <code>ActivityMainController</code> calls <code>PrimaryController.getInstance().switchToHome()</code> when exiting an activity.
                                <code>DeckManagementController</code> accesses the deck management button through
                                <code>PrimaryController.getInstance().getDeckManagementButton()</code> to trigger its animation. This creates a massive coupling
                                problem where changing <code>PrimaryController</code>'s API ripples through the entire application.</p
                            ><p>The correct design would separate these concerns:</p
                            ><ul
                                ><li>A <code>NavigationService</code> handling scene switching with clear methods like <code>navigate(String route)</code></li
                                ><li>An <code>AnimationManager</code> for UI effects</li
                                ><li>A <code>LayoutController</code> for sidebar visibility</li
                                ><li
                                    >A proper router that maps logical routes to <code>FXML</code> paths rather than having button IDs hardcoded everywhere</li
                                ></ul
                            ><p
                                >Each concern could then be tested, modified, and reasoned about independently. But that level of architectural planning wasn't
                                happening when you're learning <code>Java</code> syntax while simultaneously trying to ship features.</p
                            ><h3 id="lack-of-data-validation">Lack of Data Validation</h3><p>User inputs are minimally validated throughout the application:</p
                            ><ul
                                ><li
                                    >When creating flashcards, we check if text fields are empty but don't limit length, check for <code>SQL</code> injection
                                    patterns, or sanitise input</li
                                ><li
                                    >When creating decks, we check for empty names but allow duplicate names, special characters that might cause filesystem
                                    issues (since deck names could theoretically be used for file exports), or <code>SQL</code>-problematic strings</li
                                ><li
                                    >The user registration checks if usernames are taken but doesn't enforce password strength, email format validation, or
                                    username character restrictions</li
                                ></ul
                            ><p>This permissive approach works for a controlled university demo but would be exploited in any real-world scenario.</p
                            ><h3 id="tightly-coupled-activity-system">Tightly Coupled Activity System</h3
                            ><p
                                >The activity system reveals the consequences of rushing. <code>ActivityMainController</code> directly instantiates
                                <code>ActivityCharacterRecognition</code> controllers, calls <code>setMainController</code> on them, and expects them to call
                                back to <code>enableCheckButton</code>. This tight coupling means:</p
                            ><ul
                                ><li>Activities must know about their parent controller</li
                                ><li>The parent must know implementation details of child activities</li
                                ><li>Testing activities in isolation is impossible</li
                                ><li>Adding new activity types requires modifying <code>ActivityMainController</code></li
                                ><li>The relationship is bidirectional and fragile</li></ul
                            ><p
                                >A better design would use an event system or callback interfaces where activities publish events (<code>answerSubmitted</code>,
                                <code>activityCompleted</code>) and the main controller subscribes, decoupling the two and making the system extensible.</p
                            ><h3 id="no-separation-of-concerns-in-controllers">No Separation of Concerns in Controllers</h3
                            ><p>Controllers handle far too much:</p
                            ><ul
                                ><li
                                    ><code>FlashcardController</code> manages UI events, calls services, handles animations, formats dates, and directly
                                    manipulates style classes</li
                                ><li
                                    ><code>ProfileController</code> loads images, processes them, saves them to disk, updates the database, manages the cache,
                                    and handles UI updates</li
                                ></ul
                            ><p
                                >This violates single responsibility and makes the controllers impossible to unit test without a full
                                <code>JavaFX</code> environment. View models or presenters could have separated UI state from business logic, but
                                <code>JavaFX</code> doesn't provide this pattern out of the box, and adding it would have required more architectural planning
                                than we had time for.</p
                            ><h3 id="incomplete-features-and-dead-code">Incomplete Features and Dead Code</h3
                            ><p>The codebase shows evidence of abandoned features:</p
                            ><ul
                                ><li><code>HomeController</code> is essentially empty with just a comment about adding methods</li
                                ><li>There are multiple "test" files like <code>ActivityMainTestController</code> that seem to be experimental versions</li
                                ><li
                                    >The <code>path/to/</code> directory contains a lone <code>ProfileController.java</code> that appears to be a duplicate or
                                    old version</li
                                ><li>The <code>button_development.fxml</code> file suggests UI experimentation</li></ul
                            ><p
                                >These artifacts indicate rapid iteration without cleanup, which is understandable given time constraints but contributes to
                                cognitive overhead when navigating the code.</p
                            ><h2 id="performance-and-scalability-issues">Performance and Scalability Issues</h2><h3 id="memory-management">Memory Management</h3
                            ><p
                                >The <code>ImageCache</code> preloads all banner images on startup and keeps them in memory forever. For a small user base, this
                                is fine, but it doesn't scale. A single 720x405 image at 32-bit colour depth is roughly 1.1MB. With a hundred users, that's
                                110MB of cached images that might never be viewed. The cache has no eviction policy, no size limits, and no way to reclaim
                                memory. A production system would need <code>LRU</code> caching with size limits, but implementing that would have taken time
                                away from feature development.</p
                            ><h3 id="database-design-limitations">Database Design Limitations</h3
                            ><p>The database schema, inferred from the data access code, has limitations:</p
                            ><ul
                                ><li
                                    >The <code>flashcard_decks_table</code> and <code>flashcards_table</code> relationship uses a junction table
                                    (<code>deck_flashcards</code>), which is correct for many-to-many relationships, but there's no cascading delete logic
                                    visible in the code. If a user is deleted, their decks, flashcards, and statistics remain orphaned</li
                                ><li
                                    >The <code>character_recognition_activities_table</code> stores all possible questions statically rather than generating
                                    them dynamically, which means adding new characters requires manual database updates</li
                                ><li
                                    >The <code>user_table</code> stores passwords and profile banners in the same table as user data, which violates separation
                                    of concerns (profile metadata should be separate from authentication credentials)</li
                                ></ul
                            ><h3 id="javafx-thread-safety">JavaFX Thread Safety</h3
                            ><p
                                >The codebase uses <code>Platform.runLater</code> in several places when updating UI from background threads (image loading,
                                preloading activities), which is correct. However, the pattern isn't consistently applied. Some methods assume they're on the
                                <code>JavaFX</code> Application Thread without verification. If future development adds more background processing, race
                                conditions could emerge. <code>JavaFX</code>'s single-threaded UI model requires discipline that's hard to maintain without
                                explicit threading policies.</p
                            ><h2 id="what-i-learned-and-would-do-differently">What I Learned and Would Do Differently</h2
                            ><h3 id="understanding-java-through-practice">Understanding Java Through Practice</h3
                            ><p
                                >Learning <code>Java</code> by building a real application rather than following tutorials provided invaluable experience. I
                                learned about interfaces, abstract classes, generics, lambdas, streams, and exception handling not as abstract concepts but as
                                tools to solve real problems. The <code>try-with-resources</code> pattern for database connections, the use of
                                <code>Optional</code> for nullable values (though inconsistently applied), and the difference between checked and unchecked
                                exceptions all made sense in context. The <code>Maven</code> dependency management, package structure, and classpath issues that
                                plague beginners became clear through trial and error. This hands-on approach was messy but effective for building intuition
                                about the language.</p
                            ><h3 id="javafx39s-strengths-and-frustrations">JavaFX's Strengths and Frustrations</h3
                            ><p
                                ><code>JavaFX</code> proved capable of building rich desktop applications with sophisticated animations and layouts. The Scene
                                Builder tool helped visualise <code>FXML</code>, even if we ended up editing much of it manually for fine-grained control. The
                                <code>CSS</code> styling allowed separation of appearance from structure, though the limited selector support and property names
                                that don't quite match web standards created confusion. The built-in transition and animation APIs were powerful but verbose.
                                Achieving what might take a few lines of <code>CSS</code> animation code required creating <code>Timeline</code> objects,
                                <code>KeyFrames</code>, and <code>KeyValues</code> explicitly. The <code>FXML</code> loading and controller injection worked
                                well once understood, but error messages when <code>FXML</code> was malformed or resource paths were wrong were cryptic.
                                Overall, <code>JavaFX</code> was a reasonable choice for this project, though frameworks like <code>Electron</code> or even web
                                technologies might have offered faster iteration for UI-heavy work.</p
                            ><h3 id="the-cost-of-velocity">The Cost of Velocity</h3
                            ><p
                                >Prioritising development velocity meant accumulating technical debt that became apparent as features were added. The decision
                                to copy and modify existing controllers rather than refactor for reusability saved time initially but created maintenance
                                burden. The inconsistent error handling, minimal validation, and lack of tests all reflect the trade-off between shipping
                                features and building quality. In a six-week timeline for a demo project, this was arguably the right choice (a polished,
                                feature-complete application that works for demo purposes is more valuable than a smaller, perfectly-architected application).
                                However, this experience taught me to recognise the moments where a few hours of refactoring would have prevented days of
                                debugging later. The <code>ActivityMainController</code> duplication is a prime example; extracting the common functionality
                                after the second copy-paste would have been faster in the long run.</p
                            ><h2 id="how-it-can-be-improved">How It Can Be Improved</h2><h3 id="architectural-refactoring">Architectural Refactoring</h3
                            ><p>The application desperately needs extraction of common concerns into reusable components:</p
                            ><ul
                                ><li
                                    >An <code>ActivityManager</code> base class could handle hearts, progress tracking, button state management, and animation
                                    coordination, with specific activity types extending it</li
                                ><li>A <code>ValidationService</code> could centralise input validation with configurable rules</li
                                ><li>An <code>ErrorHandler</code> service could provide consistent error feedback to users while logging appropriately</li
                                ><li
                                    >Extracting a <code>NavigationService</code> from <code>PrimaryController</code> would clarify routing logic and make it
                                    testable</li
                                ></ul
                            ><p>These refactorings don't add features but dramatically improve maintainability.</p
                            ><h3 id="security-improvements">Security Improvements</h3
                            ><p
                                >Implementing proper password hashing with <code>bcrypt</code>, adding password strength requirements, and salting passwords
                                would address the most critical security flaw. Input sanitisation to prevent <code>SQL</code> injection, even though
                                <code>SQLite</code> with parameterised queries is relatively safe, would add defence in depth. Adding session timeout and
                                logout-on-inactivity would prevent unauthorised access on shared machines. Encrypting the local <code>SQLite</code> database
                                would protect data at rest. Adding audit logging for authentication events would support security monitoring. None of these are
                                complex, but they require prioritisation.</p
                            ><h3 id="testing-strategy">Testing Strategy</h3
                            ><p
                                >A comprehensive testing strategy would start with service layer tests, mocking the data access layer to verify business logic.
                                Integration tests would verify the full stack from controller to database. UI tests using <code>TestFX</code> could automate
                                common user workflows. Property-based tests could generate random flashcards and deck combinations to find edge cases. Mutation
                                testing could verify test effectiveness. This testing pyramid would catch regressions and enable confident refactoring. The
                                initial investment would be substantial but pay dividends in reduced debugging time.</p
                            ><h3 id="database-improvements">Database Improvements</h3
                            ><p
                                >Migrating from <code>SQLite</code> to a more robust database like <code>PostgreSQL</code> would enable better concurrency, more
                                sophisticated querying, and production readiness. Adding database migrations using <code>Flyway</code> or
                                <code>Liquibase</code> would version control schema changes. Implementing soft deletes (marking records as deleted rather than
                                removing them) would enable data recovery. Adding database indexes on frequently queried columns would improve performance.
                                Normalising the user table to separate authentication from profile data would improve security. These database improvements
                                would require reworking the data access layer but would future-proof the application.</p
                            ><h3 id="configuration-management">Configuration Management</h3
                            ><p
                                >Externalising configuration (database paths, resource locations, animation durations, API keys if we added external services)
                                into a properties file or environment variables would make the application more flexible. Different configurations for
                                development, testing, and production would support proper deployment. This would eliminate the hardcoded paths scattered
                                throughout and enable easier testing with mock databases.</p
                            ><h3 id="accessibility-and-internationalisation">Accessibility and Internationalisation</h3
                            ><p
                                >The application currently has no accessibility support. Adding <code>ARIA</code> labels for screen readers, keyboard navigation
                                support beyond the default tab order, and proper focus management would make it usable for users with disabilities.
                                Internationalisation support using resource bundles would allow translating the UI into multiple languages, appropriate for a
                                language learning application. Both require upfront architectural support rather than being addable as afterthoughts.</p
                            ><h3 id="performance-optimisation">Performance Optimisation</h3><p>Profiling the application would identify bottlenecks:</p
                            ><ul
                                ><li>The repeated opening of database connections could be pooled</li
                                ><li>The image loading could be made truly async with progress indicators</li
                                ><li>The <code>FXML</code> parsing could be cached or pre-compiled</li
                                ><li>Large lists could use virtual scrolling</li
                                ><li><code>CSS</code> could be minified</li></ul
                            ><p>These optimisations aren't necessary for current performance but would enable scaling to larger datasets.</p
                            ><h2 id="conclusion">Conclusion</h2
                            ><p
                                >Socslingo is what you get when you learn <code>Java</code> by building something real under a tight deadline. It works, it
                                demos well, and it has more features than it probably should for a six-week project. The layered architecture is standard
                                <code>MVC</code>, the animations are perhaps over-engineered, and the feature set is broad but shallow. The security is
                                questionable, there are barely any meaningful tests, and there's enough duplicated code to make any experienced developer
                                wince.</p
                            ><p
                                >Looking back, it's a snapshot of learning under pressure. The code reflects every shortcut taken, every "I'll fix this later"
                                that never got fixed, and every moment where shipping something that worked beat building something properly. That's not
                                necessarily wrong for a university project with a hard deadline, but it does mean the codebase is more of a learning artifact
                                than production-ready software. The expectations at university weren't particularly high, and this project scored near-perfect
                                marks based on demonstrating working features and meeting the requirements. But scoring well doesn't change the fact that I
                                could see substantial issues with the codebase even while building it. The assessment criteria valued functionality over code
                                quality, which is understandable for an educational setting but doesn't reflect the standards actual software development
                                demands.</p
                            ><p
                                >I've outlined various improvements above (architectural refactoring, security fixes, proper testing, database improvements),
                                but I haven't gone back to implement them. I'm currently preoccupied with Valgo, a new project that's demanding my attention,
                                and frankly, the idea of refactoring a completed university project doesn't compete with building something new. However, the
                                exercise of identifying these issues has been valuable in itself. The main lesson I've taken forward is the importance of
                                upfront research and architectural planning. For future projects, I'm spending more time researching patterns, best practices,
                                and potential pitfalls before writing code. Understanding the trade-offs of different approaches before committing to one
                                prevents the kind of technical debt that accumulated in Socslingo. It's slower initially, but faster overall when you're not
                                constantly refactoring or living with decisions made in ignorance.</p
                            ><p
                                >The value wasn't in writing perfect code. It was in discovering what happens when you don't, and learning to recognise the
                                difference. That's probably worth more than following best practices from a tutorial would have been.</p
                            ></div
                        ></div
                    ></div
                ></section
            ></main
        >
        <script src="../../assets/scripts/blog-post.js"></script> </body
></html>
